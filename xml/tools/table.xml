<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" ?>
<casaxml xmlns="http://casa.nrao.edu/schema/psetTypes.html"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://casa.nrao.edu/schema/casa.xsd
file:///opt/casa/code/tools/xml/casa.xsd">

        <tool name="table" module="table">
        <shortdescription>Access tables from casapy</shortdescription>
       
<code>
	<include>tools/tables/table_forward.h</include>
<private>
	<include>tools/tables/table_private.h</include>
</private>
</code>

<description>
table is the tool that contains all the functions relevant for
table handling.

<!-- To make a table tool, use the
<link anchor="table:table.tablefromascii.constructor">constructor</link>. -->
<!-- begin modification -->
<!-- july 2 2007 -->
<!-- Following modification introduces the fromASDM function -->
<!-- <link anchor="table:table.tablefromASDM.constructor">constructor</link>.-->
<!-- end modification -->
</description>



   <method type="constructor" name="table">
   <shortdescription>Construct table tool</shortdescription>
   
<description>
Use this constructor to construct a table tool inside casapy from
the name of a disk file containing a \casa\ Table. A
new table may also be created from a table descriptor
(see <link anchor="table:tablecreatedesc.function">tablecreatedesc</link>).
When creating a new table, detailed data manager information can be
given using the \texttt{dminfo} argument. This is a record as
returned by the <link anchor="table:table.getdminfo.function">getdminfo</link>
function.

Most of the arguments are rarely used: most of the time, you'll
just need to use the tablename, and perhaps nomodify.

A table can be shared by multiple processes by using the appropriate
locking options. The possible options are:
\\- auto: let the system take care of locking. At regular time
intervals these autolocks are released to give other processes the
opportunity to access the table. The aipsrc variable
\\\texttt{table.relinquish.reqautolocks.interval} defines the number
of seconds between releasing autolocks on tables needed in another process.
\\\texttt{table.relinquish.allautolocks.interval} defines the number
of seconds between releasing all autolocks.
\\- autonoread: as auto, but no read locking is needed. This must be
used with care, because it means that reading can be done while
the table tool is not synchronized with the table file (as is
normally done when a lock is acquired). The function \texttt{resync}
can be used to explicitly synchronize the table tool
\\- user: the user takes care by explicit calls to lock and unlock
\\- usernoread: as user and the no readlocking behaviour of autonoread.
\\- permanent: use a permanent lock; the constructor fails when the table is
already in use in another process
\\- permanentwait: as above, but wait until the other process
releases its lock
\\- default: this is the default option.
If the given table is already open, the locking option in use is not
changed. Otherwise it reverts to auto.
\\When auto locking is used, it is possible to give a record containing
the fields option, interval, and/or maxwait. In this way advanced
users have full control over the locking options. In practice this is
hardly ever needed.

When creating a new table, the endian format in which the
data should be stored, can be specified. The possible values are:
\\- big: big endian format (as used on e.g. SUN)
\\- little: little endian format (as used on e.g. PC)
\\- local: use the endian format of the machine being used
\\- aipsrc: use the endian format specified in aipsrc variable
table.endianformat (which defaults to big).
\\The default is aipsrc.
\\Note that usually it is best to store data in local endian format,
because that requires the least amount of byte swapping. However,
if the table must be accessible with AIPS++ version 1.7 or before,
big endian should be used.

When creating a new table, the table will normally reside on disk. It
is, however, possible to specify that the table should be held in
memory. In such a case the table is process specific, thus cannot be
seen by other processes. Note that a memory table uses the MemoryStMan
storage manager for all its stored columns, but it is still possible
to use virtual columns as well.

</description>
<input>
<!-- 
     <param type="string"  name="tablename">
     <description>Name of table on disk</description>
     <value></value>
     </param>

     <param type="any"  name="tabledesc">
     <description>Table descriptor</description>
     <any type="record"/>
     <value></value>
     </param>

     <param type="int"  name="nrow">
     <description>Number of rows</description>
     <value>0</value>
     </param>

     <param type="bool"  name="nomodify">
     <description>Open Read-only?</description>
     <value>true</value>
     </param>

     <param type="any"  name="lockoptions">
     <description>locking to be used</description>
     <any type="string record"/>
     <value>default</value>
     </param>

     <param type="bool"  name="ack">
     <description>Acknowledge creations, etc</description>
     <value>true</value>
     <choice>T</choice>
     </param>

     <param type="any"  name="dminfo">
     <description>Data manager info for new table</description>
     <any type="record"/>
     <value></value>
     </param>

     <param type="string"  name="endian">
     <description>Endian format of new table</description>
     <value>aipsrc</value>
     </param>

     <param type="bool"  name="memorytable">
     <description>Hold new table in memory?</description>
     <value>false</value>
     </param>

     <param type="any"  name="tableserver">
     <any type="record"/>
     <description>Table handler to be used</description>
     <value>defaulttableserver</value>
     </param>

     <param type="any"  name="tablenote">
     <description>note function to be used
     Any note function</description>
     <any type="record"/>
     </param>

     <param type="any"  name="handle">
     <description>attach to this table handle
     for internal use only</description>
     <any type="record"/>
     <value>false</value>
     </param>
-->
</input>
<returns type="table"/>

<example>

  table1:=table("3C273XC1.MS");
  table1.browse();

</example>
<comments>

The first line opens an existing table 3C273XC1.MS, the second browses
it using the <link anchor="table:table.browse.function">browse</link>
tool function.

\begin{verbatim}
  table2:=table("name", nomodify=False, lockoptions='user', endian='local');
  table2.lock();
  table2.addRows();
  table2.unlock();
\end{verbatim}
In this example explicit user locking is used. The function lock
is needed to acquire a (write) lock before the addRows is done.
Thereafter the lock is released to give other processes the chance
to operate on the table.
\\Note that releasing a lock implies flushing the table, so doing
that very often can be quite expensive.
</comments>
</method>
-->

 
   <method type="function" name="fromfits">
   <shortdescription>Create a \casa\ table from a binary FITS file</shortdescription>
   
<description>
Create a table from binary FITS format. This generates a CASA table
from the binary FITS table in the given HDU (header unit) of the
FITS file. Note that other FITS formats ({\em e.g.}
Image FITS and UVFITS) are read by other means.
\\It is possible to specify the storage manager to use for the table:
\\\texttt{standard} is the default storage manager.
\\\texttt{incremental} is efficient for slowly varying data.
\\\texttt{memort} is for in memory use for e.g to grab given columns via getcol.
</description>

<input>

     <param type="string"  name="tablename">
     <description>Name of table to be created</description>
     </param>

     <param type="string"  name="fitsfile">
     <description>Name of FITS file to be read</description>
     </param>

     <param type="int"  name="whichhdu">
     <description>Which HDU to read (0-relative to primary HDU i.e. 1 is the smallest valid value)</description>
     <value>1</value>
     </param>

     <param type="string"  name="storage">
     <description>Storage manager to use (standard or incremental or memory)</description>
     <value>standard</value>
     <allowed kind="enum">
	    <value>standard</value>
	    <value>incremental</value>
	    <value>memory</value>
     </allowed>

     </param>

     <param type="string"  name="convention">
     <description>Convention to use (sdfits or none)</description>
     <value>none</value>
     </param>

     <param type="bool"  name="nomodify">
     <description>Open Read-only?</description>
     <value>true</value>
     </param>

<!--
     <param type="any"  name="lockoptions">
     <description>locking to be used</description>
     <any type="string record"/>
     <value>default</value>
     </param>
-->
     <param type="bool"  name="ack">
     <description>Acknowledge creations, etc</description>
     <value>true</value>
     </param>

</input>
<returns type="table"/>
</method>


 
   <method type="function" name="fromascii">
   <shortdescription>Create a \casa\ table from a file containing data in ASCII format</shortdescription>
   
<description>
Create a table from an ASCII file. Columnar data as well as
table and column keywords may be specified.
\\Once the table is created from the ASCII data, it is opened in the
specified mode by the table tool. <!-- and a table tool is returned.-->

The table columns are filled from a file containing the data values
separated by a separator (one line per table row). The default
separator is a blank. Blanks after the separator are ignored.
\\If a non-blank separator is used, values can be empty. Such values
default to 0, empty string, or F depending on the data type. E.g.
1,,2, has 4 values of which the 2nd and 4th are empty and default to 0.
Similarly if fewer values are given than needed, the missing values
get the default value.

Either the data format can be explicitly specified or it can be found
automatically. The former gives more control in ambiguous situations.
Both scalar and array columns can be generated from the ASCII input.
The format string determines the type and optional shape.

In automatic mode (\texttt{autoheader=True}) the first line
of the ASCII data is analyzed
to deduce the data types. Only the types I, D, and A can be
recognized. A number without decimal point or exponent is I (integer),
otherwise it is D (double). Any other string is A (string).
Note that a number may contain a leading sign (+ or -).
The \texttt{autoshape} argument can be used to specify if the input
should be stored as multiple scalars (the default) or as a single
array. In the latter case one axis in the shape can be defined as
variable length by giving it the value 0. It means that the actual
array shape in a row is determined by the number of values in the
corresponding input line.
Columns get the names \texttt{Column1}, \texttt{Column2}, etc..
\\For example:
\begin{enumerate}
\item
\texttt{autoshape=[]} (which is the default) means that all values
are to be stored as scalar columns.
\item
\texttt{autoshape=0} means that all values in a row are to be stored as
a variable length vector.
\item
\texttt{autoshape=10} defines a fixed length vector. If an input
line contains less than 10 values, the vector is filled with default
values. If more than 10 values, the latter values are ignored.
\item
\texttt{autoshape=[5,0]} defines a 2-dim array of which the 2nd axis is
variable. Note that if an input line does not contain a multiple of 5
values, the array is filled with default values.
\end{enumerate}

If the format of the table is explicitly specified, it has to be done
either in the first two lines of the data file (named by the
argument filename), or in a separate header file (named by the
argument headerfile). In both forms, table keywords may also be
specified before the column definitions.
The column names and types can be described by two lines:

\begin{enumerate}
\item The first line contains the names of the columns.
These names may be enclosed in quotes (either single or double). 
\item The second line contains the data type and optionally the shape
of each column. Valid types are: 
\begin{itemize}
\item S for Short data 
\item I for Integer data 
\item R for Real data 
\item D for Double Precision data 
\item X for Complex data (Real followed by Imaginary) 
\item Z for Complex data (Amplitude then Phase) 
\item DX for Double Precision Complex data (Real followed by Imaginary) 
\item DZ for Double Precision Complex data (Amplitude then Phase) 
\item A for ASCII data (a value must be enclosed in single or double quotes
        if it contains whitespace) 
\item B for Boolean data (False are empty string, 0, or any string
        starting with F, f, N, or n).
\end{itemize}
\end{enumerate}
If a column is an array, the shape has to be given after the data type
without any whitespace. E.g. \texttt{I10} defines an integer vector
of length 10. \texttt{A2,5} defines a 2-dim string array with shape
[2,5]. Note that \texttt{I} is not the same as \texttt{I1} as the
first one defines a scalar and the other one a vector with length 1.
The last column can have one variable length axis denoted by the value
0. It "consumes" the remainder of the input line.

If the argument headerfile is set then the header information is
read from that file instead of the first lines of the data file.

To give a simple example of the form where the header information
is located at the top of the data file:

\begin{verbatim}
COLI   COLF   COLD       COLX        COLZ       COLS
 I      R      D          X           Z          A
1      1.1    1.11       1.12 1.13   1.14 1.15  Str1
10     11     12         13   14     15   16    ""
\end{verbatim}
Note that a complex number consists of 2 numbers.
\\Also note that an empty string can be given.

Let us now give an example of a separate header file that one might use to get
interferometer data into \casa:

\begin{verbatim}
U     V      W         TIME        ANT1       ANT2      DATA
R     R      R          D           I          I        X1,0
\end{verbatim}

The data file would then look like:

\begin{verbatim}
124.011 54560.0  3477.1  43456789.0990    1      2        4.327 -0.1132
34561.0 45629.3  3900.5  43456789.0990    1      3        5.398 0.4521
\end{verbatim}
Note that the DATA column is defined as a 2-dim array of 1
correlation and a variable number of channels, so the actual number of
channels is determined by the input. In this example both rows will
have 1 channel (note that a complex value contains 2 values).

Tables may have keywords in addition to the columns. The keywords
are useful for holding information that is global to the entire
table (such as author, revision, history, {\em etc,}).
\\The keywords in the header definitions must preceed the column descriptions.
They must be enclosed between a line that starts with ".key..." and
a line that starts with ".endkey..." (where ... can be anything).
Between these two lines each
line should contain the following as listed below.
A table keywordset and column keywordsets can be specified.
The latter can be specified by specifying the column name after the
.keywords string.

\begin{itemize}
\item The keyword name, e.g., ANYKEY 
\item The datatype and optional  shape of the keyword
      (cf. list of valid types above) 
\item The value or values for the keyword (the keyword may contain 
a scalar or an array of values). e.g., 3.14159 21.78945 
\end{itemize}

Thus to continue the example above, one might wish to add keywords
as follows:

\begin{verbatim}
.keywords
DATE        A  "97/1/16"
REVISION    D 2.01
AUTHOR      A "Tim Cornwell"
INSTRUMENT  A "VLA"
.endkeywords
.keywords TIME
UNIT A "s"
.endkeywords
U     V      W         TIME        ANT1       ANT2      DATA
R     R      R          D           I          I        X1,0
\end{verbatim}
Similarly to the column format string, the keyword formats can also
contain shape information. The only difference is that if no shape is
given, a keyword can have multiple values (making it a vector).

It is possible to ignore comment lines in the header and data file
by giving the \texttt{commentmarker}. It indicates that lines
starting with the given marker are ignored. Note that the marker can
be a regular expression (e.g. texttt{' *//'} tells that lines starting
with // and optionally preceeded by blanks have to be ignored).

With the arguments \texttt{firstline} and \texttt{lastline} one can
specify which lines have to be taken from the input file. A negative value
means 1 for \texttt{firstline} or end-of-file for \texttt{lastline}.
Note that if the headers and data are combined in one file,
these line arguments apply to the whole file. If headers and data are in
separate files, these line arguments apply to the data file only.

Also note that ignored comment lines are counted, thus are used to
determine which lines are in the line range.

The number of rows is determined by the number of lines read from the data
file. 
</description>

<input>

     <param type="string" name="tablename">
     <description>Name of table to be created</description>
     </param>

     <param type="string" name="asciifile">
     <description>Name of ASCII file to be read</description>
     </param>

     <param type="string" name="headerfile">
     <description>Name of an optional file defining the format</description>
     <value></value>
     </param>

     <param type="bool" name="autoheader">
     <description>Determine header information automatically</description>
     <value>false</value>
     </param>

     <param type="intArray" name="autoshape">
     <description>Shape to be used if autoheader=True</description>
     <value>-1</value>
     </param>

     <param type="string" name="sep">
     <description>Value separator</description>
     <value> </value>
     </param>

     <param type="string" name="commentmarker">
     <description>Regex indicating comment line</description>
     <value></value>
     </param>

     <param type="int" name="firstline">
     <description>First line to use</description>
     <value>0</value>
     </param>

     <param type="int" name="lastline">
     <description>Last line to use</description>
     <value>-1</value>
     </param>

     <param type="bool" name="nomodify">
     <description>Open Read-only?</description>
     <value>true</value>
     </param>

     <param type="stringArray" name="columnnames">
     <description>Column Names</description>
     <value></value>
     </param>

     <param type="stringArray" name="datatypes">
     <description>Data types</description>
     <value></value>
     </param>

</input>
<returns type="bool"/>
</method>

 
   <method type="function" name="open">
   <shortdescription>open an existing table</shortdescription>
   
<description>
	Opens a disk file containing an existing \casa\ Table.

Most of the time you just need to specify the tablename and perhaps
nomodify.

A table can be shared by multiple processes by using the appropriate
locking options. The possible options are:
\\- auto: let the system take care of locking. At regular time
intervals these autolocks are released to give other processes the
opportunity to access the table. <!-- The aipsrc variable
\\\texttt{table.relinquish.reqautolocks.interval} defines the number
of seconds between releasing autolocks on tables needed in another process.
\\\texttt{table.relinquish.allautolocks.interval} defines the number
of seconds between releasing all autolocks.-->
\\- autonoread: as auto, but no read locking is needed. This must be
used with care, because it means that reading can be done while
the table tool is not synchronized with the table file (as is
normally done when a lock is acquired). The function \texttt{resync}
can be used to explicitly synchronize the table tool
\\- user: the user takes care by explicit calls to lock and unlock
\\- usernoread: as user and the no readlocking behaviour of autonoread.
\\- permanent: use a permanent lock; the constructor fails when the table is
already in use in another process
\\- permanentwait: as above, but wait until the other process
releases its lock
\\- default: this is the default option.
If the given table is already open, the locking option in use is not
changed. Otherwise it reverts to auto.
\\When auto locking is used, it is possible to give a record containing
the fields option, interval, and/or maxwait. In this way advanced
users have full control over the locking options. In practice this is
hardly ever needed.


</description>
<input>
	<param type="string" name="tablename">
	<value></value>
    <type mustexist="true">path</type>
	</param>
        <param type="record" name="lockoptions">
        <description>locking dictionary to be used : dict keys are 'option', 'interval', 'maxwait'</description>
        <value></value>
        </param>
	<param type="bool" name="nomodify">
	<value>true</value>
	</param>
</input>
<returns type="bool"/>

<example>


  # First let's make a table for testing
  def maketesttable():
      # Get path to CASA home directory by stipping name from '$CASAPATH'
      pathname=os.environ.get("CASAPATH").split()[0]
      # This is where the 3C273XC1.fits data should be
      fitsdata=pathname+"/data/demo/3C273XC1.fits"
      # Remove old table if present
      !rm -rf 3C273XC1.MS
      ms.fromfits("3C273XC1.MS",fitsdata)
      ms.close()

  maketesttable()
  tb.open("3C273XC1.MS")
  tb.browse()
  tb.close()


The first line opens an existing table 3C273XC1.MS, the second browses
it using the <link anchor="table:table.browse.function">browse</link> function.


  tb.open("3C273XC1.MS", nomodify=False, lockoptions={'option':'user'})
  tb.lock();
  tb.addrows();
  tb.unlock();


In this example explicit user locking is used. The function lock
is needed to acquire a (write) lock before the addrows is done.
Thereafter the lock is released to give other processes the chance
to operate on the table.
\\Note that releasing a lock implies flushing the table, so doing
that very often can be quite expensive.



</example>

</method>

   <method type="function" name="create">
   <shortdescription>create a new table</shortdescription>
   
<description>
	Create a new \casa\ Table.

Most of the time you just need to specify the table's name and a description of
its format.

A table can be shared by multiple processes by using the appropriate
locking options. The possible options are:
\\- auto: let the system take care of locking. At regular time
intervals these autolocks are released to give other processes the
opportunity to access the table. <!-- The aipsrc variable
\\\texttt{table.relinquish.reqautolocks.interval} defines the number
of seconds between releasing autolocks on tables needed in another process.
\\\texttt{table.relinquish.allautolocks.interval} defines the number
of seconds between releasing all autolocks.-->
\\- autonoread: as auto, but no read locking is needed. This must be
used with care, because it means that reading can be done while
the table tool is not synchronized with the table file (as is
normally done when a lock is acquired). The function \texttt{resync}
can be used to explicitly synchronize the table tool
\\- user: the user takes care by explicit calls to lock and unlock
\\- usernoread: as user and the no readlocking behaviour of autonoread.
\\- permanent: use a permanent lock; the constructor fails when the table is
already in use in another process
\\- permanentwait: as above, but wait until the other process
releases its lock
\\- default: this is the default option.
If the given table is already open, the locking option in use is not
changed. Otherwise it reverts to auto.
\\When auto locking is used, it is possible to give a record containing
the fields option, interval, and/or maxwait. In this way advanced
users have full control over the locking options. In practice this is
hardly ever needed.


</description>
<input>
  <param type="string" name="tablename">
    <value></value>
  </param>
  <param type="record" name="tabledesc">
    <description>description of the table's format</description>
    <value></value>
  </param>
  <param type="record" name="lockoptions">
    <description>locking to be used</description>
    <value>default</value>
  </param>
  <param type="string" name="endianformat">
    <value></value>
  </param>
  <param type="string" name="memtype">
    <value></value>
  </param>
  <param type="int" name="nrow">
    <value>0</value>
  </param>
  <param type="record" name="dminfo">
    <description>Data Manager information</description>
    <value></value>
  </param>
</input>
<returns type="bool"/>

<example>


  # First let's get sample descriptions of a table and its data managers.
  import os, shutil

  def get_tabledesc_and_dminfo(tabname="3C273XC1.MS"):
      made_copy = False

      # Fetch new table if tabname not present
      if not os.path.isdir(tabname):
          # Get path to CASA root directory by stripping name from '$CASAPATH'
          pathname = os.environ.get("CASAPATH").split()[0]

          # There should be some data here
          fitsdata = pathname + "/data/demo/3C273XC1.fits"
          tabname = "3C273XC1.MS"

          ms.fromfits(tabname, fitsdata)
          ms.close()
          made_copy = True

      tb.open(tabname)
      tabdesc = tb.getdesc()
      dminfo  = tb.getdminfo()
      print tabname, "has", tb.nrows(), "rows."
      tb.close()

      # Clean up
      if made_copy:
          shutil.rmtree(tabname)

      return tabdesc, dminfo

  tabdesc, dmi = get_tabledesc_and_dminfo()
  tabdesc  # prints tabdesc
  dmi      # prints dmi

  # You could alter tabdesc and/or dmi at this point.

  # Unnecessary, but just to show there is nothing up my sleeve...
  tb.close()

  tb.create("myempty.ms", tabdesc, dminfo=dmi)
  tb.nrows()     # 0L
  tb.addrows(5)  # Add the rows _before_ filling the columns.
  tb.putcol('ARRAY_ID', numpy.array([0 for i in range(5)]))
  tb.putcol('ANTENNA1', numpy.array(range(5)))
  tb.putcol('ANTENNA2', numpy.array(range(1,6)))
  tb.browse()    # Still mostly, but not completely, empty.
  tb.close()


This creates a CASA table using a description of a table and its data managers from an existing MS.

</example>

</method>

 
   <method type="function" name="flush">
   <shortdescription>flush the current contents to disk</shortdescription>
   
<description>
Until a flush is performed, the results of all operations
are not reflected in any change to the
disk file. Hence you {\em must} do a flush to write the changes
to disk.
</description>
<returns type="bool"/>
</method>


<!-- begin modification -->
<!-- july 2 2007 -->
<!-- fromASDM method definition -->

   <method type="function" name="fromASDM">
   <shortdescription>Create an CASA table from an ASDM table</shortdescription>

<description>
.keywords
DATE        A  "07/7/23"
REVISION    D 0 
AUTHOR      A "Paulo C. Cortes"
INSTRUMENT  A "ALMA"
.endkeywords

The main function for this task is to create a CASA::Table from a XML  ASDM Table. The classes asdmCasaXMLUtil and asdmCasaSaxHandler are the main objects which
implement the task. The asdmCasaSaxHandler encapsulate all the operations 
returning a reference to a CASA::Table. The class uses xerces-c to parse the
XML table and creates the CASA::Table. The implementation assumes the integrity
of the XML data, it not attempting to check whether the XML  data meets a 
column format or not. In detail, an ArrayString column should agree with
the following format: nd nx ... data, where nd is the number of dimensions,
nx is the size of the first dimension (implemented upto a cube, i.e. nx,ny,nz),
and data is the array itself which should have the appropiate number of 
elements. For example, a VectorString column could be: 1 2 "I" "Q" or 
dimension 1, size 2, and two string elements. Due to the lack of data type
spefication in the XML tables, the column names are hardcoded into the 
asdmCasaSaxHandler based on the ASDM specification (see 
http://aramis.obspm.fr/~alma/ASDM/ASDMEntities/index.html). 
While missing data from a table column will be accepted by the task, 
any new column beyond the specification has to be added into the class, also,
any change in data types form the specificatin will produce a crash, CASA
is picky with data types integrity. So far, the list of tables included in 
the class is:

AlmaCorrelatorMode.xml,
Antenna.xml
ConfigDescription.xml,
DataDescription.xml,
ExecBlock.xml,
Feed.xml,
Field.xml,
Main.xml,
Polarization.xml,
Processor.xml,
Receiver.xml,
SBSummary.xml,
Scan.xml,
Source.xml,
SpectralWindow.xml,
State.xml,
Station.xml,
Subscan.xml,
SwitchCycle.xml,
CalCurve.xml,
CalData.xml,
CalPhase.xml

more tables will follow. The usage of fromASDM is simple, it gets two
string, tablename and xmlfile, where tablename is the CASA::Table to be
written and xmlfile represents the ASDM XML table. To call it do:
tb.fromasdm(tablename,xmlfile)

</description>

<input>

     <param type="string" name="tablename">
     <description>Name of table to be created</description>
     </param>

     <param type="string" name="xmlfile">
     <description>Name of the XML file to be read</description>
     </param>

</input>
<returns type="bool"/>
</method>


<!-- end modification -->

 
   <method type="function" name="resync">
   <shortdescription>resync the table tool with table file</shortdescription>
   
<description>
Acquiring a read or write lock automatically synchronizes the internals
of the table tool with the actual contents of the table files.
In this way different processes accessing the same table always
use the same table data.
\\However, a table can be used without read locking. In that case
the table tool internals are not synchronized automatically.
The resync function offers a way to do explicit synchronization.
It is only useful if the table is opened with locking mode
\texttt{autonoread} or \texttt{usernoread}.
</description>
<returns type="bool"/>
</method>

 
   <method type="function" name="close">
   <shortdescription>close the table tool</shortdescription>
   
<description>
First a flush is done, then the table is closed inside casapy and
is no longer available for use.
</description>
<returns type="bool"/>
</method>

 
   <method type="function" name="copy">
   <shortdescription>copy a table</shortdescription>
   
<description>
Copy the table. All subtables are also copied.
References to another table are preserved.

The argument \texttt{deep} determines how a reference table (i.e. the
result of a <link anchor="table:table.query.function">query</link>) is copied. By default
a file copy is made, thus the resulting table still contains
references and no actual data. If, however, \texttt{deep=True} is given,
a deep copy is made which means that the actual data are copied. Also
all subtables are copied.
\\Normally a plain table is copied by copying the files. However,
if \texttt{deep=True} and \texttt{valuecopy=True} are given, a plain table is
copied by copying all its values and subtables. This is useful to
reorganize the tables, i.e. to regain file space that is wasted by
frequent updates to a table.
\\The argument \texttt{dminfo} can be used to specify explicit data
manager info for the columns in the new plain table. It can be used to
change, for example, a storage manager from IncrStMan to StandardStMan.
The \texttt{dminfo} is a record as returned by the
<link anchor="table:table.getdminfo.function">getdminfo</link>
If \texttt{dminfo} is a non-empty record, it forces \texttt{valuecopy=True}.

The standard operation is make the copy to a plain table. It is,
however, possible to copy to a memory table by giving \texttt{memorytable=True}.

The endian format for the newly created table can be specified. This
is only meaningful if a deep copy is made to a plain table.
The possible values are:
\\- big: big endian format (as used on e.g. SUN)
\\- little: little endian format (as used on e.g. PC)
\\- local: use the endian format of the machine being used
\\- aipsrc: use the endian format specified in aipsrc variable
table.endianformat (which defaults to big).
\\The default is aipsrc.

Normally the \texttt{copy} function only copies the table and does not
create a new table tool object. The user can do that by opening the newly
created table in the standard way. However, it is possible to get an
object back by using \texttt{returnobject=True}. An object is always
returned if the copy is made to a memory table.
</description>
<input>

     <param type="string" name="newtablename">
     <description>Name of newtable on disk</description>
     </param>

     <param type="bool" name="deep">
     <description>Make a deep copy of a reference table?</description>
     <value>false</value>
     </param>

     <param type="bool" name="valuecopy">
     <description>Make a deep copy of any table?</description>
     <value>false</value>
     </param>

     <param type="record" name="dminfo">
     <description>Data manager info for new table</description>
     <value></value>
     </param>

     <param type="string" name="endian">
     <description>Endian format of new table</description>
     <value>aipsrc</value>
     </param>

     <param type="bool" name="memorytable">
     <description>Hold new table in memory?</description>
     <value>false</value>
     </param>

     <param type="bool" name="returnobject">
     <description>Return a tool object for the new table</description>
     <value>false</value>
     </param>

     <param type="bool" name="norows">
     <description>Don't copy any rows (useful for copying only the table structure)</description>
     <value>false</value>
     </param>
</input>
<returns type="table"/>
</method>

 
   <method type="function" name="copyrows">
   <shortdescription>copy rows from this table to another</shortdescription>
   
<description>
Copy rows from this table to another. By default all rows of this
table are appended to the output table. It is possible though to
control which rows are copied.
\\Rows are added to the output table as needed.
Because no rows can be added to a reference table, it is only possible
to overwrite existing rows in such tables.

Only the data of columns existing in both tables will be copied.
Thus by making a reference table consisting of a few columns, it
is possible to copy those columns only.
</description>
<input>

     <param type="string" name="outtable">
     <description>table object of output table</description>
     </param>

     <param type="int" name="startrowin">
     <description>First row to take from input table</description>
     <value>0</value>
     </param>

     <param type="int" name="startrowout">
     <description>First row to write in output table, -1 (=end)</description>
     <value>-1</value>
     </param>

     <param type="int" name="nrow">
     <description>Nr of rows to copy, -1 (=all)</description>
     <value>-1</value>
     </param>
</input>
<returns type="bool"/>
<example>
This example appends rows to the table itself, thus doubles the number
of rows.

  tb.open('3C273XC1.MS',nomodify=False)
  tb.copyrows('3C273XC1.MS')
  tb.close()

This example copies 10 rows of the selected subset of the MS to the
beginning of the output MS.

  !rm -rf in.MS out.MS
  ms.fromfits('in.MS','3C273XC1.fits')       #Make two MSs
  ms.fromfits('out.MS','3C273XC1.fits')      #for example
  ms.close()
  tb.open("in.MS")
  t1 = tb.query('ANTENNA1==0')
  tb.close()
  t1.copyrows("out.MS",nrow=10,startrowout=0)
  t1.close()

</example>
</method>

 
   <method type="function" name="done">
   <shortdescription>end the table tool</shortdescription>
   
<description>
Effectively a synonym for function <link anchor="table:table.close.function">close</link>.
</description>
<returns type="bool"/>
</method>

 
   <method type="function" name="iswritable">
   <shortdescription>is the table writable?</shortdescription>
   
<description>
Test if the table is opened for write.
<!-- \\Note that the global function \texttt{tableiswritable(tablename)}
tests if a table with the given name is writable.-->
</description>
<returns type="bool"/>
</method>

    <method type="function" name="isopened">
   <shortdescription>Is the table name open in this process</shortdescription>
   
<description>
Test if the table is opened in the  process this function is invoked

</description>
<input>

     <param type="string" name="tablename">
     <description>table name to see if it is opened</description>
     </param>
</input>
<returns type="bool"/>
</method>
   <method type="function" name="endianformat">
   <shortdescription>get the endian format used for this table</shortdescription>
   
<description>
Get the endian format used for this table.
It returns a string with value 'big' or 'little'.
</description>
<returns type="string"/>
</method>

 
   <method type="function" name="lock">
   <shortdescription>acquire a lock on the table</shortdescription>
   
<description>
Try to acquire a read or write lock on the table. Nothing will be
done if the table is already correctly locked by this process.
It is only needed when user locking is used.
When the lock is acquired, the internal caches will be synchronized
with the (possibly changed) contents of the table.
\\It is possible to specify the number of attempts to do (1 per
second) in case the table is locked by another process. The default 0
is trying indefinitely.
</description>
<input>

     <param type="bool" name="write">
     <description>Write lock? (F=read lock)</description>
     <value>true</value>
     </param>

     <param type="int" name="nattempts">
     <description>Nr of attempts</description>
     <value>0</value>
     </param>
</input>
<returns type="bool"/>
</method>

 
   <method type="function" name="unlock">
   <shortdescription>unlock and flush the table</shortdescription>
   
<description>
The table is flushed and the lock on the table is released.
This function is only needed when user locking is used.
However, it is also possible to use it with auto locking. In that case
the lock will automatically be re-acquired before the next table operation.
</description>
<returns type="bool"/>
</method>

 
   <method type="function" name="datachanged">
   <shortdescription>has data changed in table?</shortdescription>
   
<description>
This function tests if data in the table have changed (by another
process) since the last call to this function.
</description>
<returns type="bool"/>
</method>

 
   <method type="function" name="haslock">
   <shortdescription>has this process a lock on the table?</shortdescription>
   
<description>
Has this process a read or write lock on the table?
</description>
<input>

     <param type="bool" name="write">
     <description>Has it a write lock? (F=read lock)</description>
     <value>true</value>
     </param>
</input>
<returns type="bool"/>
</method>

 
   <method type="function" name="lockoptions">
   <shortdescription>get the lock options used for this table</shortdescription>
   
<description>
Get the lock options used for this table.
It returns a record with the fields: option, interval and maxwait.
The record can be used as the lockoptions argument when opening a table.
</description>
<returns type="record"/>
</method>

 
   <method type="function" name="ismultiused">
   <shortdescription>is the table in use in another process?</shortdescription>
   
<description>
Is the table still in use in another process?
If so, the table cannot be deleted.
</description>
<input>

     <param type="bool" name="checksubtables">
     <description>check if subtables are multiused?)</description>
     <value>false</value>
     </param>
</input>
<returns type="bool"/>
</method>

 
   <method type="function" name="browse">
   <shortdescription>browse a table using a graphical browser</shortdescription>
   
<description>
To start the <link anchor="table:tablebrowser">browser</link>, the environment variable
DISPLAY must be set.
</description>
<returns type="bool"/>
</method>

 
   <method type="function" name="name">
   <shortdescription>return name of table on disk</shortdescription>
   
<description>
Gives the name of the \casa\ table on disk that the
table tool has open.
</description>
<returns type="string"/>
<example>

  tb.open("3C273XC1.MS")
  tb.name()
# 3C273XC1.MS

</example>

</method>


<method type="function" name="createmultitable">
        <shortdescription>
	Create a virtually concatenated table
	</shortdescription>
        <description>
        </description>
        <input>
                <param name="outputTableName" type ="string">
		<description>name of the concatenated table</description>
		</param>

                <param name="tables" type="stringArray">
		<description>list of the names of the tables to be concatenated</description>
		</param>

                <param name="subdirname" type="string">
		<description>optional name of the subdirectory into which the input tables are moved</description>
		</param>
        </input>
        <returns type="bool"/>
        <example>
        </example>
</method>


   <method type="function" name="toasciifmt">
   <shortdescription>Write \casa\ table into an ASCII format </shortdescription>
   
<description>
Write a table into an ASCII format approximately compatible with <link anchor="table:table.fromascii">fromascii</link> except that in order to permit variable shaped arrays (as they often occur in MSs), array values are output enclosed in square brackets. 
The separator between values can be specified and defaults to a blank. Note that columns containing
invalid data or record type data are ignored and a warning is issued.

If the argument headerfile is set then the header information is
written to that file instead of the first two lines of the data file.
</description>
<input>

     <param type="string" name="asciifile">
     <description>Name of ASCII file to be written</description>
     </param>

     <param type="string" name="headerfile">
     <description>Name of an optional file defining the format</description>
     <value></value>
     </param>

     <param type="stringArray" name="columns">
     <description>Names of columns to be written, default is all</description>
     <value></value>
     </param>

     <param type="string" name="sep">
     <description>Value separator, default is one blank</description>
     <value></value>
     </param>
</input>
<returns type="bool"/>
<example>

tb.toasciifmt(asciifile='myfile3.dat', headerfile='myfile3.head', columns=['SOURCE_ID', 'NAME', 'PROPER_MOTION'], sep=', ')


will produce a comma separated ASCII output of the three columns 'SOURCE_ID', 'NAME', and 'PROPER_MOTION' in file 'myfile3.dat'
and a format description in 'myfile3.head'. 


tb.toasciifmt(asciifile='myfile.dat')


will produce a space separated ASCII output of all table columns into file 'myfile.dat'
with the first two lines containing a format description. 
</example>
</method>

 

<method type="function" name="taql">
	<shortdescription>Make a table from a TaQL command. </shortdescription>
	<description>This method Expose TaQL to the user.
		Details on TaQL maybe found at http://www.astron.nl/aips++/docs/notes/199</description>
	<input>
		<param type="string" name="taqlcommand">
			<description>TaQL expression</description>
                <value>TaQL expression</value>
		</param>
	</input>
<returns type="table">
<shortdescription>a table tool with the TaQL results
</shortdescription>
</returns>
<example>
	For more information on TaQL see http://www.astron.nl/aips++/docs/notes/199
</example>
</method>
 
<method type="function" name="query">
  <shortdescription>Make a table from a query</shortdescription>
   
<description>
Make a table from a query applied to the current table. <!-- The query
is the qualification part of the <link
anchor="table:tablecommand">tablecommand</link>.--> It is possible to
specify column(s) and/or expressions to sort on and to specify the
columns to be contained in the output table.  See the example below.
A new "on-the-fly" table tool is returned. The new (reference) table
can be given a name and will then be written to disk. Note that the
resulting table is just a reference to the original table.  One can
make a deep copy of the query result using the <link
anchor="table:table.copy.function">copy</link> function (see example).

<!-- If the arguments \texttt{query}, \texttt{sortlist}, and
\texttt{columns} are empty strings (their default values), the
<link anchor="widgets:taqlwidget">taqlwidget</link>
will be started (if a GUI is available) before the query function is
executed. In that way it is possible to let the user form the query
interactively.-->
</description>
<input>

     <param type="string" name="query">
     <description>Query string</description>
     <value>String</value>
     </param>

     <param type="string" name="name">
     <description>Name of resulting reference table</description>
     <value></value>
     </param>

     <param type="string" name="sortlist">
     <description>Sort string (one or more expressions separated by commas)</description>
     <value></value>
     </param>

     <param type="string" name="columns">
     <description>List of column names separated by commas</description>
     <value></value>
     </param>

     <param type="string" name="style">
     <description>How to handle numeric ranges and order axes</description>
     <value></value>
     </param>
</input>
<returns type="table">
<shortdescription>a table tool with the query results
</shortdescription>
</returns>
<example>

  tb.open("3C273XC1.MS")
  subt=tb.query("OBSERVATION_ID==0",
                sortlist="ARRAY_ID", columns="TIME, DATA, UVW")
  print subt.ncols()
# 23
  tb.close()
  copyt = subt.copy ("3C273XC1_spw1.MS", True)
  subt.close()
  copyt.close()

From the original table corresponding to the disk file 3C273XC1.MS, only rows
with OBSERVATION\_ID equal to 0 are selected and sorted by ARRAY\_ID. Only the
columns TIME DATA UVW are written. Thereafter a deep copy of the result is
made.  This table query command is equivalent to the Table Query Language
(TaQL) command

  SELECT TIME, DATA, UVW
  FROM 3C273XC1.MS
  WHERE OBSERVATION_ID==0
  ORDERBY ARRAY_ID

See http://www.astron.nl/casacore/trunk/casacore/doc/notes/199.html for an explanation of TaQL.

If "style" is not blank, "using style \&lt;style\&gt; " is prepended to the
query.  See
http://www.astron.nl/casacore/trunk/casacore/doc/notes/199.html#x1-50002.2 for
an explanation and list of choices for style.  The default (glish) style is
1-based, inclusive end, and Fortran ordering.  You may prefer python (0-based,
exclusive end, and C order) style.

tb.open('any_data')
tsel = tb.selectrows([0])
print tsel.nrows() # returns 1
tsel = tb.query('ROWNUMBER()==0')
print tsel.nrows() # returns 0
tsel = tb.query('ROWNUMBER()==0', style='python')
print tsel.nrows() # returns 1
tb.close()

Note that style had no effect on the "OBSERVATION_ID==0" query above.

</example>

<example>
The sortlist argument can be used to sort in ascending or descending
order (or a mix of them) on one or more columns. Default is ascending.
It is also possible to remove duplicate values using the word
NODUPLICATES at the beginning.

E.g.:


  sortlist='TIME desc'
  sortlist='noduplicates ANTENNA1,ANTENNA2'
  sortlist='ANTENNA1 desc, ANTENNA2 asc'
  sortlist='desc ANTENNA1, ANTENNA2, TIME'

</example>

<!-- <seealso>
<link anchor="table:tablecommand">tablecommand</link>
</seealso> -->
</method>

   <method type="function" name="calc">
   <shortdescription> TaQL expression with calc to calculate an expression on a table</shortdescription>
   
<description>


Get the result from the calculation of an expression on a table
<!-- using a CALC command given to the <link anchor="table:tablecommand">tablecommand</link>
function. -->
The expression can be any expression that can be given in the WHERE
clause of a SELECT expression (thus including subqueries).
The given expression determines if the result is a scalar, a vector,
or a record containing arrays. See the examples below.
</description>
<input>

     <param type="string" name="expr">
     <description>Expression string</description>
     </param>
     <param type="string" name="prefix">
     <description>TaQL prefix  for style and ordering etc ...check TaQL note 199 for usage</description>
     <value>using style base0, endincl, fortranorder</value>
     </param>
     <param type="bool" name="showtaql">
     <description>Show the full taql command used</description>
     <value>false</value>
     </param>

</input>
<returns type="any">
<any type="variant"/>
</returns>
<example>


tb.calc('[select from ngc5921.ms  giving [mean(abs(DATA))]]')

find the mean of the abs of each row of the  DATA column of the MeasurementSet ngc5921.ms 

returns a (potentially enormous) record where a field contains the
value of the expression for the row with that number. Note that it
returns a record because for each row the expression results in an array.
It should be clear that this example is useless. However, something
like this could be useful for a column with (very) small arrays.

tb.calc('[select from ngc5921.ms.contsub giving  [ntrue(FLAG)]]')
 

returns for each row the number of flags set. The result is a vector,
because for each row the expression results in a scalar.


tb.calc('sum([select from ngc5921.ms.contsub giving  [ntrue(FLAG)]])')

returns the total number of flags set in the table (in a single
scalar).

using subrow array 
tb.calc('median([select from ngc5921.ms where ANTENNA1==3 &amp;&amp; ANTENNA2==5 giving [abs(DATA[0,31])]])')

The above will find the median channel 31 and 0th pol of the requested  baseline formed with antennas 3 and 5.
Note that the that the default casa order of arrays is fortran order ...pol axis is before channel axis

tb.calc('median([select from ngc5921.ms where ANTENNA1==3 &amp;&amp; ANTENNA2==5 giving [abs(DATA[31, 0])]])', prefix='using style python')

Now the same is as the above but using the python style of axis ordering access


</example>

<!-- <seealso>
<link anchor="table:tablecommand">tablecommand</link>
</seealso> -->
</method>

 
   <method type="function" name="selectrows">
   <shortdescription>Make a table from a selection of rows</shortdescription>
   
<description>
Create a (reference) table containing a given subset of rows.
It is, for instance, useful when a selection is done
on another table containing the row numbers in the main table.
It can be useful to apply the casapy function unique to those
row numbers, otherwise the same row might be included multiple
times (see example).

<!-- Note that usually such referencing row numbers are 0-based, while
the selectrows function expects 1-based row numbers. It means that
in such cases 1 should be added (see example). -->

It is possible to give a name to the resulting table. If given,
the resulting table is made persistent with that table name.
Otherwise the table is transient and disappears when closed or when
casapy exits.

The <link anchor="table:table.rownumbers.function">rownumbers</link> function returns a
vector containing the row number in the main table for each row in the
selection table.
Thus given a row number vector \texttt{rownrs}, the following is
always true.
\begin{verbatim}
  rownrs == tb.selectrows(rownrs).rownumbers()
\end{verbatim}
However, it is not true when selectrows is used on a selection table.
because \texttt{rownumbers} does not return the row number in that
selection table but in the main table.
\\It means that one has to take great care when using
\texttt{selectrows} on a selection table.
</description>
<input>

     <param type="intArray" name="rownrs">
     <description>0-based Row Numbers</description>
     </param>

     <param type="string" name="name">
     <description>Name of resulting table</description>
     <value></value>
     </param>
</input>
<example>

# EXAMPLE NOT VERIFIED SINCE query IS BROKEN
#   Do the query on the main table.
  tb.open('SOMENAME')
  scantable = tb.query(command)
#   Get the column containing the 0-based row numbers in the BACKEND table.
#   Make the row numbers unique.  NEED TO REPLACE GLISH unique FUNCTION HERE!
  backrows = unique(scantable.getcol('NS_GBT_BACKEND_ID'))
#   Form the table subset of the BACKEND table containing those rows.
  tb.close()
  tb.open('SOMENAME/GBT_BACKEND')
  scanback = tb.selectrows(backrows);
#   Do something with that table.
  print scanback.nrows();


<!--
The last statement is equivalent to the query command:
\begin{verbatim}
  scanback = tb.query("rownumber() in $backrows");
\end{verbatim}
However, the query takes much, much, much more time to execute,
especially for larger tables and larger row number vectors.
Furthermore, the \texttt{backrows} variable need to be global to be
able to substitute it in the query command.
-->

</example>

<returns type="table">
<shortdescription>table tool</shortdescription>
</returns>
</method>

 
   <method type="function" name="info">
   <shortdescription>get the info record</shortdescription>
   
<description>
The info record contains information on the table. 

</description>
<returns type="record"/>

<!--
<example>
\begin{verbatim}
\end{verbatim}
</example>
-->
</method>


   <method type="function" name="putinfo">
   <shortdescription>set the info record</shortdescription>
   
<description>
The info record contains information on the table. It is
written by applications, and used <!-- by, for example, the <link anchor="catalog">catalog</link> directory browser --> to determine what type of
information is stored in a table.

</description>
<input>

     <param type="record" name="value">
     <description>Info record</description>
     </param>
</input>
<returns type="bool"/>

<!--
<example>
\begin{verbatim}
  include 'catalog.g'
  dc.whatis("MS")
# [type=Measurement Set, istable=True, subType=observed]
  dc.whatis("tcal")
# [type=Calibration, istable=True, subType=T Jones]
\end{verbatim}
</example>
-->
</method>

 
   <method type="function" name="addreadmeline">
   <shortdescription>add a readme line to the info record</shortdescription>
   
<description>
A readme line is part of the info record associated with a table.
It is to inform the user, and is not used by any application directly.
</description>
<input>

     <param type="string" name="value">
     <description>readme line</description>
     </param>
</input>
<returns type="bool">Bool</returns>
</method>

 
   <method type="function" name="summary">
   <shortdescription>summarize the contents of the table</shortdescription>
   
<description>
A (terse) summary of the table contents is sent to the defaultlogger.
</description>
<input>

     <param type="bool" name="recurse">
     <description>Summarize subtables recursively</description>
     <value>false</value>
     </param>
</input>
<returns type="bool"/>
<example>

  tb.open("tcal")
  tb.summary()
# successful nomodify open of table  tcal :  9 columns, 11 rows
# Table summary: tcal
# Shape: 9 columns by 11 rows
# Info: [type=Calibration, subType=T Jones, readme=]
# Table keywords: [Type=T Jones, Interval=30, DeltaT=1]
# Columns: StartTime StopTime Gain SolutionOK Fit FitWeight
# iSolutionOK iFit iFitWeight

</example>
</method>

 
   <method type="function" name="colnames">
   <shortdescription>return the names of the columns</shortdescription>
   
<description>
The names of the columns in the table are returned as a vector
of Strings.
</description>
<returns type="stringArray"/>
<example>

  tb.open("tcal")
  tb.colnames()
# StartTime StopTime Gain SolutionOK Fit FitWeight iSolutionOK iFit iFitWeight

</example>
</method>

 
   <method type="function" name="rownumbers">
   <shortdescription>!!!INPUT PARAMETERS IGNORED!!! return the row numbers in the (reference) table</shortdescription>
   
<description>

!!!NOTE INPUT PARAMETERS IGNORED!!!

This function can be useful after a selection or a sort.
It returns the row numbers of the rows in this table with respect
to the given table. If no table is given, the original table is used.
\\For example:
\begin {verbatim}
!!!NOTE INPUT PARAMETERS IGNORED!!!

  tb.open('3C273XC1.MS')
  t1=tb.selectrows([1,3,5,7,9])
  t1.rownumbers()
# [1L, 3L, 5L, 7L, 9L]
  t2=t1.selectrows([2,4])
  t2.rownumbers(t1)
# [2L, 4L]
  t2.rownumbers(tb.name())
# [5L, 9L]
  t2.rownumbers()
# [5L, 9L]
\end{verbatim}
The last statements show that the function returns the row numbers
referring to the given table. Table t2 contains rows 2 and 4 in table t1,
which are rows 5 and 9 in table '3C273XC1.MS'.

Note that when a table is opened using its name, that table can
be a reference table. Thus in the example above
the last 2 statements may give different results depending on the fact
if 3C273XC1.MS is a reference table or not.
\\The function should always be called with a table argument.
The ability of omitting the argument is only present for backward
compatibility.

The function can be useful to get the correct values from the result of a
getcol or getcolslice on the original table.

!!!NOTE INPUT PARAMETERS IGNORED!!!
</description>

<input>

     <param type="record" name="tab">
     <description>Table to which the row numbers refer</description>
     <value></value>
     </param>

     <param type="int" name="nbytes">
     <description>Maximum cache size in bytes</description>
     <value>0</value>
     </param>
</input>
<returns type="intArray"/>
<example>

!!!NOTE INPUT PARAMETERS IGNORED!!!
  tb.open("3C273XC1.MS")
  tb.nrows()
#7669L
  data=tb.getcolslice("DATA", [0,0], [0,0])
  data.shape
#(1, 1, 7669)
  selt=tb.query("ANTENNA1==1")
  selt.nrows()
#544L
  print len(selt.rownumbers())
#544L

</example>

<!--  subdata:=data[,,selt.rownumbers(t)]
  subdata::shape
# [300] -->


</method>

 
   <method type="function" name="setmaxcachesize">
   <shortdescription>set maximum cache size for column in the table</shortdescription>
   
<description>
It can sometimes be useful to limit the size of the cache used by
a column stored with the tiled storage manager.
This function requires some more knowledge about the table system
and is not meant for the casual user.
</description>
<input>

     <param type="string" name="columnname">
     <description>Name of column</description>
     </param>

     <param type="int" name="nbytes">
     <description>Maximum cache size in bytes</description>
     </param>
</input>
<returns type="bool"/>
<example>

  tb.open("3C273XC1.MS")
  tb.nrows()
# 7669L
  tb.setmaxcachesize ("DATA", 4*1024*1024);
# True

</example>
</method>

 
   <method type="function" name="isscalarcol">
   <shortdescription>is the specified column scalar?</shortdescription>
   
<description>
A column may contain either scalars or arrays in each cell. 
This tool function tests if the specified column has scalar contents.
</description>
<input>

     <param type="string" name="columnname">
     <description>Name of column</description>
     </param>
</input>
<returns type="bool"/>
<example>

  tb.open("tcal")
  tb.isscalarcol("StartTime")
# True
  tb.open("tcal")
  tb.isscalarcol("Gain")
# False

</example>
</method>

 
   <method type="function" name="isvarcol">
   <shortdescription>tell if column contains variable shaped arrays</shortdescription>
   
<description>
This functions tells if the column contains variable shaped arrays.
If so, the function \texttt{getvarcol} should be used to get the
entire column. Otherwise \texttt{getcol} can be used.
</description>
<input>

     <param type="string" name="columnname">
     <description>Name of column</description>
     </param>
</input>
<returns type="bool"/>
</method>

 
   <method type="function" name="coldatatype">
   <shortdescription>return the column data type</shortdescription>
   
<description>
A column may contain various data types. This tool function returns the
type of the column as a string.
</description>
<input>

     <param type="string" name="columnname">
     <description>Name of column</description>
     </param>
</input>
<returns type="string"/>
<example>

  tb.open("tcal")
  tb.coldatatype("StartTime")
# double
  tb.open("tcal")
  tb.coldatatype("Gain")
# complex

</example>
</method>

 
   <method type="function" name="colarraytype">
   <shortdescription>return the column array type</shortdescription>
   
<description>
The possible column array types are defined as:
\begin{description}
\item[FixedShape]  FixedShape means that the shape of the array must be the
same in each cell of the column. If not given, the array
shape may vary. Option Direct forces FixedShape. 
\item[Direct] Direct means that the data is directly stored in the 
table. Direct forces option FixedShape. If not given, the array is
indirect, which implies that the data will be stored in a
separate file.  
\end{description}
</description>
<input>

     <param type="string" name="columnname">
     <description>Name of column</description>
     </param>
</input>
<returns type="string"/>
<example>

  tb.open("tcal")
  tb.colarraytype("Gain")
# Direct,FixedShape

</example>
</method>

 
   <method type="function" name="ncols">
   <shortdescription>return number of columns</shortdescription>
   
<returns type="int"/>
<example>

  tb.open("3C273XC1.MS")
  tb.ncols()
# 23L

</example>
</method>

 
   <method type="function" name="nrows">
   <shortdescription>return number of rows</shortdescription>
   
<description>
Note that rows are numbered starting at 0.
</description>
<returns type="int"/>
<example>

  tb.open("3C273XC1.MS")
  tb.nrows()
# 7669L

</example>
</method>

 
   <method type="function" name="addrows">
   <shortdescription>add a specified number of rows</shortdescription>
   
<description>
Rows can be added to the end of a table that was opened nomodify=False.
The new rows are empty.
</description>
<input>

     <param type="int" name="nrow">
     <description>Number of rows to add</description>
     <value>1</value>
     </param>
</input>
<returns type="bool"/>
</method>

 
   <method type="function" name="removerows">
   <shortdescription>remove the specified rows</shortdescription>
   
<description>
Remove the row numbers specified in the vector from the table.
It fails when the table does not support row removal.
</description>
<input>

     <param type="intArray" name="rownrs">
     <description>Row numbers to remove</description>
     </param>
</input>
<returns type="bool"/>
</method>

 
   <method type="function" name="addcols">
   <shortdescription>!!!REQUIRES COLUMN DESCRIPTION FUNCTIONS THAT HAVE NOT BEEN IMPLEMENTED!!!
add one or more columns</shortdescription>
   
<description>
Columns can be added to a table that was opened nomodify=False.
The new columns will be filled with a default value (0 or blank).


!!!THESE COLUMN DESCRIPTION FUNCTIONS HAVE NOT BEEN IMPLEMENTED!!!
\\For each column to be added a column description has to be setup
using function
<link anchor="table:tablecreatescalarcoldesc.function">tablecreatescalarcoldesc</link> or
<link anchor="table:tablecreatearraycoldesc.function">tablecreatearraycoldesc</link>.
When multiple columns are used, they have to be combined in a single
record using
<link anchor="table:tablecreatedesc.function">tablecreatedesc</link>. 
\\It is possible to specify data manager info in order to define a
data manager (storage manager or virtual column engine) for the
columns to be added.
</description>
<input>

     <param type="record" name="desc">
     <description>Description of one or more columns</description>
     </param>

     <param type="record" name="dminfo">
     <description>Optional description data manager to use</description>
     <value></value>
     </param>
</input>
<returns type="bool"/>
<example>

!!!REQUIRES COLUMN DESCRIPTION FUNCTIONS THAT HAVE NOT BEEN IMPLEMENTED!!!
  tb.open("mytable", nomodify=False)
  dc3=tablecreatescalarcoldesc('C3', 'a')   
  dc4=tablecreatescalarcoldesc('C4', as_float(0))
  dc5=tablecreatearraycoldesc('C5', as_double(0), 2, [10,20])
  tb.addcols(dc3)
# True
  tb.addcols(tablecreatedesc(dc4, dc5))
# True

A single column can be added as such, but multiple columns have
to be combined.
</example>
</method>

 
   <method type="function" name="renamecol">
   <shortdescription>rename a column</shortdescription>
   
<description>
A column can be renamed in a table that was opened nomodify=False.
\\However, renaming is not possible in a (reference) table resulting
from a select or sort operation.
</description>
<input>

     <param type="string" name="oldname">
     <description>name of column to be renamed</description>
     </param>

     <param type="string" name="newname">
     <description>new name of column</description>
     </param>
</input>
<returns type="bool"/>
<example>

  tb.open("3C273XC1.MS", nomodify=False)
  tb.renamecol ('DATA', 'DATA2')
# T
  print tb.colnames()
  tb.renamecol ('DATA2', 'DATA')
# T
  print tb.colnames()

Column \texttt{DATA} is renamed to \texttt{DATA2} and then back to
\texttt{DATA} again..
</example>
</method>

 
   <method type="function" name="removecols">
   <shortdescription>remove one or more columns</shortdescription>
   
<description>
Columns can be removed from a table that was opened nomodify=False.
\\It may not always be possible to remove a column, because some data
managers do not support column removal. However, if all columns of
a data manager are removed, it will always succeed. It results in the
removal of the entire data manager (and its possible files).
\\Note that function <link anchor="table:table.getdminfo.function">getdminfo</link>
can be used to find which columns are served by which data manager.
</description>
<input>

     <param type="stringArray" name="columnames">
     <description>names of columns to be removed</description>
     </param>
</input>
<returns type="bool"/>
<example>

  tb.open("mytable", nomodify=False)
  tb.removecols ("col1 col2")
# T
  print tb.colnames()

Two columns are removed.
</example>
</method>

 
   <method type="function" name="iscelldefined">
   <shortdescription>test if a specific cell contains a value</shortdescription>
   
<description>
A column containing variable shaped arrays can have an empty cell
(if no array has been put into it). This function tests if a cell
is defined (thus is not empty).
Note that a scalar column and a fixed shape array column cannot have
empty cells.
</description>
<input>

     <param type="string" name="columnname">
     <description>Name of column</description>
     </param>

     <param type="int" name="rownr">
     <description>Row number, starting at 0</description>
     <value>0</value>
     </param>
</input>
<returns type="bool"/>
</method>

 
   <method type="function" name="getcell">
   <shortdescription>get a specific cell</shortdescription>
   
<description>
A cell is the value at one row in one column. It may be a scalar
or an array.
</description>
<input>

     <param type="string" name="columnname">
     <description>Name of column</description>
     </param>

     <param type="int" name="rownr">
     <description>Row number, starting at 0</description>
     <value>0</value>
     </param>
</input>
<returns type="any">
     <any type="variant"/>
</returns>
</method>

 
   <method type="function" name="getcellslice">
   <shortdescription>get a slice from a specific cell</shortdescription>
   
<description>
A cell is the value at one row in one column. It must be an array.
The slice must be specified as blc, trc with an optional stride.
\\In blc and trc -1 can be used to indicate all values for a dimension
(-1 in blc is equivalent to 0, so -1 is especially useful for trc).
</description>
<input>

     <param type="string" name="columnname">
     <description>Name of column</description>
     </param>

     <param type="int" name="rownr">
     <description>Row number, starting at 0</description>
     </param>

     <param type="intArray" name="blc">
     <description>Bottom left corner (e.g. [0,0,0] is start of 3D array)</description>
     </param>

     <param type="intArray" name="trc">
     <description>Top right corner</description>
     </param>

     <param type="intArray" name="incr">
     <description>Stride (defaults to 1 for all axes)</description>
     <value>1</value>
     </param>
</input>
<returns type="any">
<shortdescription>array</shortdescription>
     <any type="variant"/>
</returns>
<example>

  tb.open("3C273XC1.MS")
  data=tb.getcellslice("DATA", 0, [0,0], [1,0])
  print data.shape
# [2 1]

</example>
</method>

 
   <method type="function" name="getcol">
   <shortdescription>get a specific column</shortdescription>
   
<description>
The entire column (or part of it) is returned. Warning: it might be big!
The functions can only be used if all arrays in the column have the
same shape. That is guaranteed for columns containing scalars or fixed
shaped arrays. For columns containing variable shaped arrays it only
succeeds if all those arrays happen to have the same shape.
\\Note that function \texttt{getvarcol} can be used to get a column of
arbitrary shaped arrays, which also handles empty cells correctly.
Function \texttt{isvarcol} tells if a column contains variable shaped arrays.
shaped 
</description>
<input>

     <param type="string" name="columnname">
     <description>Name of column</description>
     </param>

     <param type="int" name="startrow">
     <description>First row to read (default 0)</description>
     <value>0</value>
     </param>

     <param type="int" name="nrow">
     <description>Number of rows to read (default -1 means till the end)</description>
     <value>-1</value>
     </param>

     <param type="int" name="rowincr">
     <description>Increment in rows to read (default 1)</description>
     <value>1</value>
     </param>
</input>
<returns type="any">
<shortdescription>array</shortdescription>
     <any type="variant"/>
</returns>
<example>

  tb.open("3C273XC1.MS")
# True
  gain=tb.getcol("DATA")
  print gain.shape
# (4, 1, 7669)

</example>
</method>

 
   <method type="function" name="getvarcol">
   <shortdescription>get a specific column (for variable arrays)</shortdescription>
   
<description>
Function \texttt{getcol} can only used if values in the column cells to get
have the same shape. Function \texttt{getvarcol} addresses this limitation by
returning the values as a record instead of an array. Each field in
the record contains the value for a column cell. If the value is
undefined (i.e. the cell does not contain a value), the unset value is
put in the record. Each field name is the letter r followed by the
row number. The length of the record is the number of rows to get.
\\Note that the function \texttt{isvarcol} tells if a column contains
variable shaped arrays.
</description>
<input>

     <param type="string" name="columnname">
     <description>Name of column</description>
     </param>

     <param type="int" name="startrow">
     <description>First row to read (default 0)</description>
     <value>0</value>
     </param>

     <param type="int" name="nrow">
     <description>Number of rows to read (default -1 means till the end)</description>
     <value>-1</value>
     </param>

     <param type="int" name="rowincr">
     <description>Increment in rows to read (default 1)</description>
     <value>1</value>
     </param>
</input>
<returns type="record"/>
<example>

  tb.open("3C273XC1.MS")
  gain=tb.getvarcol("DATA")
  print len(gain)
# 7669

</example>
</method>

 
   <method type="function" name="getcolslice">
   <shortdescription>get a slice from a specific column</shortdescription>
   
<description>
A slice from the entire column (or part of it) is returned.
Warning: it might be big!
\\In blc and trc -1 can be used to indicate all values for a dimension
(-1 in blc is equivalent to 1, so -1 is especially useful for trc).
Note that blc and trc should not contain the row number, only the
blc and trc of the arrays in the column.
</description>
<input>

     <param type="string" name="columnname">
     <description>Name of column</description>
     </param>

     <param type="intArray" name="blc">
     <description>Bottom left corner (e.g. [0,0,0] is start of 3D array)</description>
     </param>

     <param type="intArray" name="trc">
     <description>Top right corner</description>
     </param>

     <param type="intArray" name="incr">
     <description>Stride (defaults to 1 for all axes)</description>
     </param>

     <param type="int"  name="startrow">
     <description>First row to read (default 0)</description>
     <value>0</value>
     </param>

     <param type="int"  name="nrow">
     <description>Number of rows to read (default -1 means till the end)</description>
     <value>-1</value>
     </param>

     <param type="int"  name="rowincr">
     <description>Increment in rows to read (default 1)</description>
     <value>1</value>
     </param>
</input>
<shortdescription>array</shortdescription>
<returns type="any">
     <any type="variant"/>
</returns>
<example>

  tb.open("3C273XC1.MS")
  data=tb.getcolslice("DATA", [0,0], [1,0])
  data.shape
# (2 1 7669)

</example>
</method>

 
   <method type="function" name="putcell">
   <shortdescription>put a specific cell</shortdescription>
   
<description>
A cell is the the value at one row in one column. It
may be a scalar or an array.
</description>
<input>

     <param type="string"  name="columnname">
     <description>Name of column</description>
     </param>

     <param type="intArray"  name="rownr">
     <description>Row number(s) (0-relative)</description>
     </param>

     <param type="any"  name="thevalue">
     <description>Value</description>
     <any type="variant"/>
     </param>
</input>
<returns type="bool"/>
</method>

 
   <method type="function" name="putcellslice">
   <shortdescription>put a slice into a specific cell</shortdescription>
   
<description>
A cell is the value at one row in one column. It must be an array.
The slice must be specified as blc, trc with an optional stride.
\\In blc and trc -1 can be used to indicate all values for a dimension
(-1 in blc is equivalent to 0, so -1 is especially useful for trc).
</description>
<input>

     <param type="string"  name="columnname">
     <description>Name of column</description>
     </param>

     <param type="int"  name="rownr">
     <description>Row number, starting at 0</description>
     </param>

     <param type="any"  name="value">
     <description>Value</description>
     <any type="variant"/>
     </param>

     <param type="intArray"  name="blc">
     <description>Bottom left corner (e.g. [0,0,0] is start of 3D array)</description>
     </param>

     <param type="intArray"  name="trc">
     <description>Top right corner</description>
     </param>

     <param type="intArray"  name="incr">
     <description>Stride (defaults to 1 for all axes)</description>
     <value>1</value>
     </param>
</input>
<returns type="bool"/>
</method>

 
   <method type="function" name="putcol">
   <shortdescription>put a specific column</shortdescription>
   
<input>

     <param type="string"  name="columnname">
     <description>Name of column</description>
     </param>

     <param type="any"  name="value">
     <description>Array</description>
     <any type="variant"/>
     </param>

     <param type="int"  name="startrow">
     <description>First row to put (default 0)</description>
     <value>0</value>
     </param>

     <param type="int"  name="nrow">
     <description>Number of rows to put (default -1 means till the end)</description>
     <value>-1</value>
     </param>

     <param type="int"  name="rowincr">
     <description>Increment in rows to put (default 1)</description>
     <value>1</value>
     </param>
</input>
<returns type="bool"/>
<example>

  tb.open("3C273XC1.MS",nomodify=False)
  data=tb.getcol("DATA")
  # [could modify data here]
  tb.putcol("DATA", data)
  tb.flush()

</example>
</method>

 
   <method type="function" name="putvarcol">
   <shortdescription>put a specific column (for variable arrays)</shortdescription>
   
<description>
\texttt{putcol} can only used if values in the column cells to put
have the same shape. \texttt{putvarcol} addresses this limitation by
passing the values as a record instead of an array. Each field in
the record contains the value for a column cell. So the length of the
record has to match the number of rows to put. If a value is the unset
value, no put is done for that row.
</description>
<input>

     <param type="string"  name="columnname">
     <description>Name of column</description>
     </param>

     <param type="record"  name="value">
     <description>Record with values</description>
     </param>

     <param type="int"  name="startrow">
     <description>First row to put (default 0)</description>
     <value>0</value>
     </param>

     <param type="int"  name="nrow">
     <description>Number of rows to put (default -1 means till the end)</description>
     <value>-1</value>
     </param>

     <param type="int"  name="rowincr">
     <description>Increment in rows to put (default 1)</description>
     <value>1</value>
     </param>
</input>
<returns type="bool">Bool</returns>
<example>

  tb.open("3C273XC1.MS",nomodify=False)
  gain=tb.getvarcol("DATA", 0, 10)
  tb.putvarcol("Gain", gain, 10, 10)
  tb.flush()

This example copies the values from row 0-9 to row 10-19.
</example>
</method>

 
   <method type="function" name="putcolslice">
   <shortdescription>put a slice into a specific column</shortdescription>
   
<description>
In blc and trc, -1 can be used to indicate all values for a dimension
(-1 in blc is equivalent to 0, so -1 is especially useful for trc).
Note that blc and trc should not contain the row number, only the
blc and trc of the arrays in the column.
</description>
<input>

     <param type="string"  name="columnname">
     <description>Name of column</description>
     </param>

     <param type="any"  name="value">
     <description>Array</description>
     <any type="variant"/>
     </param>

     <param type="intArray"  name="blc">
     <description>Bottom left corner (e.g. [0,0,0] is start of 3D array)</description>
     </param>

     <param type="intArray"  name="trc">
     <description>Top right corner</description>
     </param>

     <param type="intArray"  name="incr">
     <description>Stride (defaults to 1 for all axes)</description>
     <value>1</value>
     </param>

     <param type="int"  name="startrow">
     <description>First row to put (default 0)</description>
     <value>0</value>
     </param>

     <param type="int"  name="nrow">
     <description>Number of rows to put (default -1 means till the end)</description>
     <value>-1</value>
     </param>

     <param type="int"  name="rowincr">
     <description>Increment in rows to put (default 1)</description>
     <value>1</value>
     </param>
</input>
<returns type="bool"/>
<example>

  tb.open("3C273XC1.MS",nomodify=False)
  data_all=tb.getcolslice("DATA", [-1,-1], [-1,=1])
  print data_all.shape
  # (4, 1, 7669)
  data=tb.getcolslice("DATA", [0,0],[3,0])
  # can modify data here
  tb.putcolslice("DATA", data, [0,0],[3,0])
  tb.flush()

</example>
</method>

 
   <method type="function" name="getcolshapestring">
   <shortdescription>get shape of arrays in a specific column</shortdescription>
   
<description>
The shapes of the arrays in the entire column (or part of it) are
returned as strings like [20,3]. When the column contains fixed shaped
arrays, a single string is returned. Otherwise a vector of strings is
returned.
</description>
<input>

     <param type="string"  name="columnname">
     <description>Name of column</description>
     </param>

     <param type="int"  name="startrow">
     <description>First row to read (default 0)</description>
     <value>0</value>
     </param>

     <param type="int"  name="nrow">
     <description>Number of rows to read (default -1 means till the end)</description>
     <value>-1</value>
     </param>

     <param type="int"  name="rowincr">
     <description>Increment in rows to read (default 1)</description>
     <value>1</value>
     </param>
</input>
<returns type="stringArray"/>
<example>

  tb.open("3C273XC1.MS")
  shapes=tb.getcolshapestring("DATA"))
  print len(shapes)

</example>
</method>

 
   <method type="function" name="getkeyword">
   <shortdescription>get value of specific table keyword</shortdescription>
   
<description>
The value of the given table keyword is returned. The value can be of any
type, including a record and a table.
\\If a keyword is a table, its value is returned as a string containing
the table name prefixed by 'Table: '. <!-- That prefix is automatically
removed by table functions like \texttt{open} and \texttt{tableexists}.-->
\\It is possible that the value of a keyword is a record itself
(arbitrarily deeply nested). A field in such a subrecord can be
read by separating the name with dots.
</description>
<input>

     <param type="any"  name="keyword">
     <description>Name or seqnr of keyword: string or int</description>
     <any type="variant"/>
     </param>
</input>
<returns type="any">
     <any type="variant"/>
</returns>
<example>

  tb.open('3C273XC1.MS')
  tb.getkeywords()
  tb.getkeyword('MS_VERSION')
# 2.0
  tb.close()
  tb.open('tcal')
  tb.getkeyword('rec.fld')     # get field from a record
# 3.14

</example>
</method>

 
   <method type="function" name="getkeywords">
   <shortdescription>get values of all table keywords</shortdescription>
   
<description>
The values of all table keywords are returned. The values can be of any
type, including a record and a table.
\\If a keyword is a table, its value is returned as a string containing
the table name prefixed by 'Table: '. <!-- That prefix is automatically
removed by table functions like \texttt{open} and \texttt{tableexists}.-->
</description>
<returns type="record"/>
<example>

  tb.open('3C273XC1.MS')
  tb.getkeywords()
#{'ANTENNA': 'Table: /home/aips2mgr/testing/3C273XC1.MS/ANTENNA',
# 'DATA_DESCRIPTION': 'Table: /home/aips2mgr/testing/3C273XC1.MS/DATA_DESCRIPTION',
# 'FEED': 'Table: /home/aips2mgr/testing/3C273XC1.MS/FEED',
# 'FIELD': 'Table: /home/aips2mgr/testing/3C273XC1.MS/FIELD',
# 'FLAG_CMD': 'Table: /home/aips2mgr/testing/3C273XC1.MS/FLAG_CMD',
# 'HISTORY': 'Table: /home/aips2mgr/testing/3C273XC1.MS/HISTORY',
# 'MS_VERSION': 2.0,
# 'OBSERVATION': 'Table: /home/aips2mgr/testing/3C273XC1.MS/OBSERVATION',
# 'POINTING': 'Table: /home/aips2mgr/testing/3C273XC1.MS/POINTING',
# 'POLARIZATION': 'Table: /home/aips2mgr/testing/3C273XC1.MS/POLARIZATION',
# 'PROCESSOR': 'Table: /home/aips2mgr/testing/3C273XC1.MS/PROCESSOR',
# 'SOURCE': 'Table: /home/aips2mgr/testing/3C273XC1.MS/SOURCE',
# 'SPECTRAL_WINDOW': 'Table: /home/aips2mgr/testing/3C273XC1.MS/SPECTRAL_WINDOW',
# 'STATE': 'Table: /home/aips2mgr/testing/3C273XC1.MS/STATE'}

</example>
</method>

 
   <method type="function" name="getcolkeyword">
   <shortdescription>get value of specific column keyword</shortdescription>
   
<description>
The value of the given column keyword is returned. The value can be of any
type, including a record and a table.
\\If a keyword is a table, its value is returned as a string containing
the table name prefixed by 'Table: '. <!-- That prefix is automatically
removed by table functions like \texttt{open} and \texttt{tableexists}.-->
\\It is possible that the value of a keyword is a record itself
(arbitrarily deeply nested). A field in such a subrecord can be
read by separating the name with dots.
</description>
<input>

     <param type="string"  name="columnname">
     <description>Name of column</description>
     </param>

     <param type="any"  name="keyword">
     <description>Name or seqnr of keyword: string or int</description>
     <any type="variant"/>
     </param>
</input>
<returns type="any">
     <any type="variant"/>
</returns>
<example>

  tb.open("3C273XC1.MS")
  tb.getcolkeyword("UVW", "QuantumUnits")
#array(['m', 'm', 'm'],
#      dtype='|S2')

</example>
</method>

 
   <method type="function" name="getcolkeywords">
   <shortdescription>get values of all keywords for a column</shortdescription>
   
<description>
The values of all keywords for the given column are returned.
The values can be of any type, including a record and a table.
\\If a keyword is a table, its value is returned as a string containing
the table name prefixed by 'Table: '. <!-- That prefix is automatically
removed by table functions like \texttt{open} and \texttt{tableexists}.-->
</description>
<input>

     <param type="string"  name="columnname">
     <description>Name of column</description>
     </param>
</input>
<returns type="any">
<any type="variant"/>
</returns>
<example>

  tb.open("3C273XC1.MS")
  tb.getcolkeywords("UVW")
#{'MEASINFO': {'Ref': 'ITRF', 'type': 'uvw'},
# 'QuantumUnits': array(['m', 'm', 'm'],
#      dtype='|S2')}

</example>
</method>

 
   <method type="function" name="putkeyword">
   <shortdescription>put a specific table keyword</shortdescription>
   
<description>
Put a table keyword. The value of the keyword can be a scalar or
an array of any type or it can be a record.
\\It is possible to define a keyword holding a subtable. In that
case a special string containing the name of the subtable will be
passed to the table client.
\\It is possible that the value of a keyword is a record itself
(arbitrarily deeply nested). A field in such a subrecord can be
written by separating the name with dots. If a subrecord does not
exist, an error is returned unless \texttt{makesubrecord=True} is given.
In such a case intermediate records are created when needed.
</description>
<input>

     <param type="any"  name="keyword">
     <description>Name or seqnr of keyword: string or int</description>
     <any type="variant"/>
     </param>

     <param type="any"  name="value">
     <description>Value of keyword</description>
     <any type="variant"/>
     </param>

     <param type="bool"  name="makesubrecord">
     <description>Create intermediate records</description>
     <value>false</value>
     </param>
</input>
<returns type="bool">Bool</returns>
<example>

  tb.open("3C273XC1.MS", nomodify=False)
  tb.putkeyword("VERSION", "1.66")
# True
#      define ANTENNA subtable
  tb.putkeyword("ANTENNA", 'Table: 3C273XC1.MS/ANTENNA')
  tb.flush()
# True
#      write a field in a record and create subrecords when needed
  tb.putkeyword("REC.SUB.FLD", "val", True)
# True
#      write a keyword with a record value
  tb.putkeyword("REC", {'SUB': {'FLD': 'val'}})
# True

Note that the last example does the same as the previous one (assuming
that \texttt{REC} does not exist yet with other fields).
</example>
</method>

 
   <method type="function" name="putkeywords">
   <shortdescription>!!!BROKEN!!! put multiple table keywords</shortdescription>
   
<description>
Put multiple table keywords. All fields in the given record are put
as table keywords. The value of each field can be a scalar or
an array of any type or it can be a record.
\\It is also possible to define a keyword holding a subtable.
This can be done by giving the keyword a string value consisting of
the subtable name prefixed by 'Table: '. <!-- Remember to use single quotes,
otherwise casapy turns it into a string vector. -->
</description>
<input>

     <param type="record"  name="value">
     <description>Record of keyword=value pairs</description>
     </param>
</input>
<returns type="bool"/>
<example>

  tb.open('3C273XC1.MS', nomodify=False)
  kw=tb.getkeywords()
  print kw['MS_VERSION']
# 2.0
  kw['MS_VERSION']=2.1
  tb.putkeywords(kw)
# !!!BROKEN. Keywords containing float are not handled properly!!!
  tb.flush()
# True

</example>
</method>

 
   <method type="function" name="putcolkeyword">
   <shortdescription>put a specific keyword for a column</shortdescription>
   
<description>
Put a keyword in the given column.
The value of the keyword can be a scalar or
an array of any type or it can be a record.
\\It is possible to define a keyword holding a subtable. In that
case a special string containing the name of the subtable will be
passed to the table client.
\\It is possible that the value of a keyword is a record itself
(arbitrarily deeply nested). A field in such a subrecord can be
written by separating the name with dots. If a subrecord does not
exist, an error is returned unless \texttt{makesubrecord=True} is given.
In such a case intermediate records are created when needed.
</description>
<input>

     <param type="string"  name="columnname">
     <description>Name of column</description>
     </param>

     <param type="any"  name="keyword">
     <description>Name or seqnr of keyword,string or int</description>
     <any type="variant"/>
     </param>

     <param type="any"  name="value">
     <description>Value of keyword</description>
     <any type="variant"/>
     </param>
</input>
<returns type="bool"/>
<example>

  tb.open("3C273XC1.MS", nomodify=False)
  ckw=tb.getcolkeyword("UVW","QuantumUnits")
  print ckw
  # modify ckw as desired
  tb.putcolkeyword("UVW","QuantumUnits",ckw)
# True
  tb.flush()
# True

</example>
</method>

 
   <method type="function" name="putcolkeywords">
   <shortdescription>put multiple keywords for a column</shortdescription>
   
<description>
Put multiple keywords in the given column.
All fields in the given record are put
as column keywords. The value of each field can be a scalar or
an array of any type or it can be a record.
\\It is also possible to define a keyword holding a subtable.
This can be done by giving the keyword a string value consisting of
the subtable name prefixed by 'Table: '. <!-- Remember to use single quotes,
otherwise casapy turns it into a string vector. -->
</description>
<input>

     <param type="string"  name="columnname">
     <description>Name of column</description>
     </param>

     <param type="record"  name="value">
     <description>Record of keyword=value pairs</description>
     </param>
</input>
<returns type="bool"/>
<example>

  tb.open("3C273XC1.MS", nomodify=False)
  kws = tb.getcolkeywords("UVW")
  kws
#{'MEASINFO': {'Ref': 'ITRF', 'type': 'uvw'},
# 'QuantumUnits': array(['m', 'm', 'm'],
#      dtype='|S2')}
  kws['MEASINFO']['Ref']='B1950'
  tb.putcolkeywords(kws)
# True

</example>
</method>

 
   <method type="function" name="removekeyword">
   <shortdescription>remove a specific table keyword</shortdescription>
   
<input>

     <param type="any"  name="keyword">
     <description>Name or seqnr of keyword: string or int</description>
     <any type="variant"/>
     </param>
</input>
<returns type="bool"/>
<example>

  tb.open("3C273XC1.MS", nomodify=False)
  tb.removekeyword("MS_VERSION")
# True
  tb.flush()
# True

</example>
</method>

 
   <method type="function" name="removecolkeyword">
   <shortdescription>remove a specific keyword for a column</shortdescription>
   
<input>

     <param type="string"  name="columnname">
     <description>Name of column</description>
     </param>

     <param type="any"  name="keyword">
     <description>Name or seqnr of keyword: string or int</description>
     <any type="variant"/>
     </param>
</input>
<returns type="bool"/>
<example>

  tb.open("3C273XC1.MS", nomodify=False)
  tb.removecolkeyword("UVW", "QuantumUnits")
# True
  tb.flush()
# True

</example>
</method>

 
   <method type="function" name="getdminfo">
   <shortdescription>get the info about data managers</shortdescription>
   
<description>
This function returns the types and names of the data managers used.
For each data manager it also returns the names of the columns served by it.
The information is returned as a record containing a subrecord for
each data manager. Each subrecord contains the fields TYPE, NAME and
COLUMNS.
</description>
<returns type="record"/>
<example>

  tb.open('3C273XC1.MS')
  rec = tb.getdminfo()

Print the output record shows that the table uses 9 storage managers.
</example>
</method>

 
   <method type="function" name="keywordnames">
   <shortdescription>get the names of all table keywords</shortdescription>
   
<description>
This function returns a vector of strings containing the names
of all table keywords.
</description>
<returns type="stringArray"/>
</method>

 
   <method type="function" name="fieldnames">
   <shortdescription>get the names of fields in a table keyword</shortdescription>
   
<description>
This function returns a vector of strings containing the names
of all fields in the given table keyword.
It is only valid if the keyword value is a record.
\\If no keyword name is given, the names of all table keywords are returned.
</description>
<input>

     <param type="string" name="keyword">
     <description>keyword name</description>
     <value></value>
     </param>
</input>
<returns type="stringArray"/>
</method>

 
   <method type="function" name="colkeywordnames">
   <shortdescription>get the names of all keywords in a column</shortdescription>
   
<description>
This function returns a vector of strings containing the names
of all keywords in the column with the given name..
</description>
<input>

     <param type="string" name="columnname">
     <description>column name</description>
     </param>
</input>
<returns type="stringArray"/>

<example>

  tb.open('3C273XC1.MS')
  tb.colkeywordnames("UVW")

</example>

</method>

 
   <method type="function" name="colfieldnames">
   <shortdescription>get the names of fields in a keyword in a column</shortdescription>
   
<description>
This function returns a vector of strings containing the names
of all fields in the given keyword in the given column.
It is only valid if the keyword value is a record.
\\If no keyword name is given, the names of all keywords in the column
are returned.
</description>
<input>

     <param type="string" name="columnname">
     <description>column name</description>
     </param>

     <param type="string" name="keyword">
     <description>keyword name</description>
     <value></value>
     </param>
</input>
<returns type="stringArray"/>
</method>

 
   <method type="function" name="getdesc">
   <shortdescription>get the table description</shortdescription>
   
<description>
The table description is a casapy record that contains a complete 
description of the layout
of the table (except for the number of rows). <!-- It can be used as a
template in the creation of another table using the table constructor. -->
\\
By default the actual table description is returned (thus telling the
actual shapes and data managers used). It is also possible to get
the table description used when creating the table.
</description>
<input>

     <param type="bool"  name="actual">
     <description>actual table description?</description>
     <value>true</value>
     </param>
</input>
<returns type="record">
<shortdescription>Table description record
</shortdescription>
</returns>
<example>

  tb.open("3C273XC1.MS")
  tb.getdesc()

</example>
</method>

 
   <method type="function" name="getcoldesc">
   <shortdescription>get the description of a specific
column</shortdescription>
   
<description>
The column description is a casapy record that contains a complete 
description of the layout
of a specified column (except for the number of rows). It can be used 
to construct a table description.
</description>
<input>

     <param type="string"  name="columnname">
     <description>Name of column</description>
     </param>
</input>
<returns type="record">
<shortdescription>Column description record
</shortdescription>
</returns>
<example>

  tb.open("3C273XC1.MS")
  tb.getcoldesc("DATA")
#{'comment': 'The data column',
# 'dataManagerGroup': 'TiledData',
# 'dataManagerType': 'TiledShapeStMan',
# 'maxlen': 0,
# 'ndim': 2,
# 'option': 0,
# 'valueType': 'complex'}

</example>
</method>

 
   <method type="function" name="ok">
   <shortdescription>Is the table tool ok?</shortdescription>
   
<description>
Perform a number of sanity checks and return T if ok.
Failure (returning F) is a sign of a bug.
</description>
<returns type="bool"/>
</method>
 
   <method type="function" name="clearlocks">
	   <shortdescription>Clears any table lock associated with the current process</shortdescription>
   
<description>
	Occasionally a table will be inretrievably locked to another process no matter how much closing is done.
	So clearLocks will unlock all the files in the table cache that use AutoLocking.
</description>
<returns type="bool"/>
</method>

   <method type="function" name="listlocks">
	   <shortdescription>Lists any table lock associated with the current process</shortdescription>
   
<description>
	Occasionally a table will be inretrievably locked to another process no matter how much closing is done.
	So listLocks will list the offending tables (and unoffending ones, too), so we can figure out where the problem might be.
</description>
<returns type="bool"/>
</method>


   <method type="function" name="statistics">
   <shortdescription>Get statistics on the selected table column</shortdescription>
   
  <keyword>statistics</keyword>
  <input>
    
     <param type="string" name="column">
     <description>Column name</description>
     </param>

     <param type="string" name="complex_value">
     <description>Which derived value to use for complex columns (amp, amplitude, phase, imag, real, imaginary)</description>
     <value></value>
     </param>
    
     <param type="bool" name="useflags">
     <description>Use the data flags</description>
     <value>true</value>
     </param>

  </input>
  <returns type="record"/>

  <description>
    This function computes descriptive statistics on the table column.
    It returns the statistical values as a dictionary.  The given 
    column name must be a numerical column.
    If it is a complex valued column, the parameter complex\_value defines
    which derived real value is used for the statistics computation.
  </description>
  <example>
    
      
      tb.open("ggtau.1mm.amp.gcal")
      s = tb.statistics(column="GAIN", complex_value="phase")
    
  </example>
</method>

<method type="function" name="showcache">
   <shortdescription>show the contents of the table cache</shortdescription>
   
<description>
Show the contents of the table cache.
</description>
<input>
	<param type="bool" name="verbose">
	<value>true</value>
	</param>
</input>
<returns type="stringArray"/>

<example>
tb.showcache()
</example>

</method>

   <method type="function" name="testincrstman">
   
        <shortdescription>Checks consistency of an Incremental Store Manager bucket layout</shortdescription>
        
        <description>
        
        Checks consistency of an Incremental Store Manager bucket layout
        
        In case of corruption it returns False and a SEVERE msg is posted containing information about the location of the corrupted bucket
        
        </description>
        
  		<input>
    
     		<param type="string" name="column">
     			<description>Column name</description>
     		</param>

  		</input>
        
        <returns type="bool"/>
        	
        <example>
        
        	mytb = tbtool()
        	mytb.open('uid___A002_X841035_X203.ms.split')
        	mytb.testincrstman('FLAG_ROW')        
        
        </example>
        
   </method>

</tool>
</casaxml>

