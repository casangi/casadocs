

.. _Description:

Description
   The **deconvolve** task performs image-domain deconvolution with options for automasking and restoration. It can be
   viewed as the minor cycle of the iterative image reconstruction offered by the **tclean** task. The functionality that
   it introduces is the ability to just run the deconvolution step alone.

   The **deconvolve** task uses the same minor cycle as tclean. Therefore, the two tasks will evaluate the minor cycle in
   the exact same way. However, **deconvolve** operates purely in the image domain and the final residual images are saved to
   disk at the end of the minor cycle iterations. In **tclean**, the residual images are saved to disk after an
   additional major cycle. The results between **deconvolve** and **tclean** may therefore differ at a level that varies per
   dataset and algorithm setup.

   This task gathers many of its runtime parameters from the meta data stored within the input images. It also doesn't have a
   need for data selection or a measurement set, and therefore requires much fewer input parameters than the **tclean**
   task. At the end of a successful **deconvolve** run, the history of the output images is updated. This is done in the
   same way as for the **tclean** task. For every **deconvolve** command a series of entries is recorded, including the
   task name "deconvolve", the CASA version used, and every parameter-value pair of the task, which can then be inspected
   with the task `imhistory <../casatasks.information.imhistory.html#casatasks.information.imhistory>`__.

   .. rubric:: Images
   
   The *imagename* parameter determines the name prefix used to find input images and defines output images. For all uses,
   the .psf and .residual images are always required. See the `parameter description <imagename_>`_ for a full list of
   expected images.

   Input/output images may be 4D CASA Image Cubes with the axis ordering set to [ra,dec,pol,chan] as is the default for
   **tclean** (`see the Correcting Axes example <Correcting_Axes_>`_). All input 2D and 3D images must be regridded to a
   4D CASA image prior to being supplied as input.

   .. TODO uncomment in CAS-13570 once test_multirun_mtmfs3x passes
   .. For deconvolving with the “mtmfs” deconvolver, most of the input images need to be the taylor series components of the
   .. images as generated by **tclean**, including the psf, residual, model, and pb.
   .. There must be `N` .residual, `N` .model (if included), `2*N-1` .psf, and `1` .pb (if included) images, where N=nterms.
   .. This will result in `N` .image output images. Some example image names for the psf are imagename.psf.tt0,
   .. imagename.psf.tt1, ..., imagename.psf.ttN.

   .. rubric:: Iteration Control

   The `niter parameter <niter_>`_ for **deconvolve** sets the maximum number of iterations possible per channel/stokes plane
   being deconvolved. It is equivalent to **tclean**'s cycleniter parameter. 

   .. note:: Each call to deconvolve starts at an iteration count of 0. Multiple successive calls to deconvolve (with the same
             image names) will start from the model image found on disk, but the iteration counts will always start from zero. 
             Therefore, for a single plane image, deconvolve(niter=10);deconvolve(niter=10) will each report doing 10 iterations, 
             but the image that results from the two successive calls will be equivalent to the result from deconvolve(niter=20).
             
   .. note:: Niter is the maximum possible per channel/stokes plane, and for cube imaging iterations are counted across all planes
             of the image. Therefore, the total number of iterations for a cube imaging run can reach a maximum of nchan x niter. 
             This behaviour is similar to that in the **tclean** task. 
             

   More information on the per-call iteration control results can be found in the return dictionary.
   
   For more details about minor cycle stopping criteria, please refer to the **tclean** 
   `iteration control documentation <../../notebooks/synthesis_imaging.html#Iteration-Control>`__ .
   
   .. rubric:: Interactive Mask

   The `interactive parameter <interactive_>`_ allows for modifying the masks and parameters before deconvolution. The
   interactive GUI starts immediately, and user may draw masks and edit iteration control parameters. If other masking
   parameters are set, the mask is first evaluated and then displayed in the interactive Clean GUI for additional
   interactive changes.
   
   .. note:: If a mask already exists on disk, with a name that matches imagename.mask, it will automatically load that mask 
             when the interactive clean window opens.  Prior to running **deconvolve**, if **tclean** is run with niter=0 
             (with no mask supplied) to generate the initial images, please note that a mask filled with ones will be generated
             on disk and this will get loaded when the **deconvolve** task interactive clean window opens. Please check the 
             cursor tab on the GUI for the mask image values.

   
   .. rubric:: Return Value:

   For niter >= 0, the **deconvolve** task returns a dictionary containing a summary of the run. The `fullsummary parameter <fullsummary_>`_ controls the amount of the information returned in the dictionary. The **deconvolve** task returns a shorten version of the summary dictionary by omittiong some 'summaryminor' inforamation when this parameter is set to False.

    Example Return Value:

   .. code-block:: python

    {
            'cleanstate': 'running',
            'cyclefactor': 1.0,
            'cycleiterdone': 0,
            'cycleniter': 2,
            'cyclethreshold': 0.0,
            'interactiveiterdone': 0,
            'interactivemode': False,
            'interactiveniter': 0,
            'interactivethreshold': 0.0,
            'iterdone': 4,
            'loopgain': 0.1,
            'maxpsffraction': 0.800,
            'maxpsfsidelobe': 0.137,
            'minpsffraction': 0.100,
            'niter': 2,
            'nmajordone': 0,
            'nsigma': 0.0,
            'stopcode': 1,
            'summarymajor': array([], dtype=int64),
            'summaryminor': { 0: {
                0: { 0: {
                    'startIterDone': [0.0],
                    'iterDone': [2.0],
                    'startPeakRes': [1.500],
                    'peakRes': [1.215],
                    'startModelFlux': [0.0],
                    'modelFlux': [0.285],
                    'startPeakResNM': [1.500],
                    'peakResNM': [1.215],
                    'cycleThresh': [0.0],
                    'cycleStartIters': [0.0],
                    'masksum': [10000.0],
                    'mpiServer': [0.0],
                    'peakMem': [11.022],
                    'runtime': [0.100],
                    'stopCode': [1.0]}},
                1: { 0: {
                    'startIterDone': [2.0],
                    'iterDone': [2.0],
                    'startPeakRes': [0.750],
                    'peakRes': [0.607],
                    'startModelFlux': [0.0],
                    'modelFlux': [0.142],
                    'startPeakResNM': [0.750],
                    'peakResNM': [0.607],
                    'cycleThresh': [0.0],
                    'cycleStartIters': [0.0],
                    'masksum': [10000.0],
                    'mpiServer': [0.0],
                    'peakMem': [11.022],
                    'runtime': [0.100],
                    'stopCode': [1.0]
                } }
            } },
            'threshold': 0.0
       }

   .. |nbsp| unicode:: 0xA0 
      :trim:

   For more information on the return value from **tclean** and **deconvolve**, please refer to the notebook "`Synthesis Imaging <../../notebooks/synthesis_imaging.html#Returned-Dictionary>`__".



.. _Examples:

Examples
   .. _Basic_Usage:
   .. rubric:: Basic Usage

   Build the '.image' image from the '.residual' and '.psf' images, as given by tclean or some other task.

   .. code-block:: python

      from casatools import ctsys
      refim_path = ctsys.resolve('unittest/deconvolve/')

      # remove the old run, as necessary
      os.system("rm -rf try.*")

      # create the .residual and .psf images
      tclean(vis=refim_path+'refim_point.ms', imagename='try', imsize=100, cell='8.0arcsec', niter=0)

      # run deconvolve to generate the .image image
      ret=deconvolve(imagename='try', deconvolver='clark', niter=20) # “restoration” defaults to True

   This works for all of the common cases, including:

   .. TODO add mtmfs and asp
   .. TODO "2D, 3D, and 4D images/cubes" => "2D, 3D, and 4D images/cubes and multi-term (for mtmfs)"

   - All the deconvolvers (hogbom, clark, clarkstokes, multiscale)
   - 2D, 3D, and 4D images/cubes, regridded as appropriate to have axes [ra,dec,pol,chan]
   - Restoration with a common beam or restoringbeam
   - Masking (user, pbmask, automask)
   - With a different start model
   
   .. TODO uncomment in CAS-13570 once test_multirun_mtmfs3x passes
   ..   .. _Basic_Usage_with_MTMFS_Deconvolver:
   ..   .. rubric:: Basic Usage with MTMFS Deconvolver
   ..
   ..   Build the '.image.tt\*' images from the '.residual.tt\*' and '.psf.tt\*' images, as given by tclean or some other task. This
   ..   is an expansion on the `Basic Usage example <Basic_Usage_>`_, showing how the 'nterms' parameter affects the taylor terms
   ..   image generation.
   ..
   ..   .. code-block:: python
   ..
   ..      from casatools import ctsys
   ..      refim_path = ctsys.resolve('unittest/deconvolve/')
   ..
   ..      # remove the old run, as necessary
   ..      os.system("rm -rf try.*")
   ..
   ..      # Use tclean to generate our taylor term images. This should produce the images:
   ..      # try.psf.tt0...try.psf.tt4, try.residual.tt0...try.residual.tt2, try.pb.tt0
   ..      tclean(vis=refim_path + 'refim_point.ms', imagename='try', imsize=10, cell='8.0arcsec',
   ..             deconvolver='mtmfs', niter=0, restoration=False, calcres=True, nterms=3)
   ..
   ..      # Deconvolve with the same deconvolver and nterms. This should produce the images:
   ..      # try.model.tt0...try.model.tt2, try.image.tt0...try.image.tt2, try.residual.tt0...try.residual.tt2
   ..      ret=deconvolve(imagename='try', niter=10, deconvolver='mtmfs', nterms=3)

   .. _Multiple_Runs:
   .. rubric:: Multiple Runs

   Run deconvolve multiple times. This can be done with all of the same parameters and the same deconvolver algorithm. This should
   give the same results as running deconvolve once with the same total number of iterations. With the code below, we should get
   the same result as when running the `Basic Usage example <Basic_Usage_>`_.

   .. code-block:: python

      from casatools import ctsys
      refim_path = ctsys.resolve('unittest/deconvolve/')

      # remove the old run, as necessary
      os.system("rm -rf try.*")

      # create the .residual and .psf images
      tclean(vis=refim_path+'refim_point.ms', imagename='try', imsize=100, cell='8.0arcsec', niter=0)

      # run deconvolve for 20 total iterations (10x2)
      ret1=deconvolve(imagename='try', deconvolver='clark', niter=10, interactive=0)
      ret2=deconvolve(imagename='try', deconvolver='clark', niter=10, interactive=0)

   .. _Automasking_Experimentation:
   .. rubric:: Automasking Experimentation

   Task deconvolve can be used in conjunction with task tclean to quickly home in on the correct automasking parameters. Running the
   task many times in a row to watch how the mask evolves is much faster with deconvolve because the slow major cycle of tclean is avoided.

   .. code-block:: python

      ###############################################################################
      # autotest_script.py
      ###############################################################################

      import shutil

      def setup():
          '''Get the ms and evaluate tclean'''
          os.system('rm -rf try.* *.ms bak')
          os.system('mkdir bak')
          refdatapath = ctsys.resolve('unittest/deconvolve/')
          shutil.copytree(refdatapath+'refim_twochan.ms', 'refim_twochan.ms')

          tclean(vis='refim_twochan.ms', imagename='try', niter=0, imsize=100, cell='8.0arcsec', \
                 deconvolver='hogbom', usemask='auto-multithresh', restoration=False, calcres=True)
          os.system("cp -rp try.* bak/")

      def restore_files(restore=False):
          '''Get the image files for a clean deconvolution test'''
          os.system('rm -rf try.*')
          os.system('cp -rp bak/* ./')

      ### Try out different automasking parameters with deconvolve.
      ### Parameters to play with: sidelobethreshold, noisethreshold, lownoisethreshold, negativethreshold, smoothfactor, minbeamfrac, cutthreshold, growiterations, dogrowprune, fastnoise
      ### To be run with "casa -c autotest_script.py":
      setup() # only need to do this the first time running the script
      restore_files()
      # Evaluate some number of times with a for loop to watch how the automask evolves.
      for n in range(10):
          ret=deconvolve(imagename='try', niter=10, deconvolver='hogbom', interactive=True, usemask='auto-multithresh', verbose=True)

   .. _Multiple_Clean_Methods:
   .. rubric:: Multiple Clean Methods

   Start with one deconvolve method, then switch to a different deconvolve method. For example, the multiscale clean method is slow
   but makes quick progress in the beginning, so start with multiscale clean and then switch to the much faster hogbom clean.

   .. code-block:: python

      from casatools import ctsys
      g55path = ctsys.resolve('RSRO/SNR/LBand_G55.7+3.4')

      def run_G55(cycle, init=False, deconvolver='hogbom', niter=200):
          '''
          Run tclean's major cycle to get multiscale RHS images.
          Run deconvolve separately on this.
          '''
          if (init):
              print("Initializing!!!")

          if cycle=='major':
              if init==True:
                  os.system('rm -rf tdec_G55*')
              print("Running a major cycle with tclean")
              vis = g55path+'/G55.7+3.4_cal.ms'
              tclean(vis=vis, imagename='tdec_G55', deconvolver=deconvolver, gridder='wproject', \
                     wprojplanes=24, cell='8.0arcsec', imsize=1024, weighting='briggs', niter=0)

          elif cycle=='minor':
              print("Running a minor cycle")
              if deconvolver == 'hogbom':
                  ret=deconvolve(imagename='tdec_G55', deconvolver=deconvolver, niter=niter, \
                                 interactive=0)
              elif deconvolver == 'multiscale':
                  ret=deconvolve(imagename='tdec_G55', deconvolver=deconvolver, niter=niter, \
                                 interactive=0, scales=[0,6,10,20,30], smallscalebias=-0.6)
              else:
                  print("unrecognized deconvolver \""+deconvolver+"\"")
                  return

          else:
              print("Unrecognized cycle argument value \""+cycle+"\"")

      for i in range(5):
          run_G55(cycle='major', init=(i==0))
          run_G55(cycle='minor', deconvolver='multiscale', niter=5)
          run_G55(cycle='minor', deconvolver='hogbom', niter=195)

   .. _Correcting_Axes:
   .. rubric:: Correcting Axes

   The tasks imtrans, importfits, and imregrid (and the image tool) can be used to correct coordinate systems, shape, and axes
   ordering in images. For example, when importing fits images, the stokes axis might be the third axis instead of the fourth.
   This code can be used to correct such a situation before running task deconvolve:

   .. code-block:: python

      # import fits images
      importfits('try_residual.fits', imagename='try_orig.residual')
      importfits('try_psf.fits', imagename='try_orig.psf')

      # fix axes for residual
      imhead('try_orig.residual')
      # in terminal: 'axisnames':...['Right Ascension', 'Declination', 'Stokes', 'Frequency']...
      imtrans('try_orig.residual', outfile='try_slast.residual', order='0132')
      imhead('try_slast.residual')
      # in terminal: 'axisnames':...['Right Ascension', 'Declination', 'Frequency', 'Stokes']...
      #              'refval':...[5.23369701e+00, 7.10938054e-01, 1.49998515e+09, 1.00000000e+00]...

      # fix axes for psf
      # Note: the image.adddegaxes tool can also be used to add new axes
      imhead('try_orig.psf')
      # in terminal: 'axisnames':...['Right Ascension', 'Declination']...
      importfits('try_psf.fits', imagename='try_orig.psf',
                 defaultaxes=True, defaultaxesvalues=['','','1.5GHz','I'], overwrite=True)
      imtrans('try_orig.psf', outfile='try_slast.psf', order='0132')
      imhead('try_slast.psf')
      # in terminal, psf: 'axisnames':...['Right Ascension', 'Declination', 'Frequency', 'Stokes']...

      # perform deconvolution
      ret=deconvolve('try_slast')

   .. _Working_with_SD_Images:
   .. rubric:: Working with SD Images

   Single Dish images can be deconvolved as long as they meet the input requirements (see the imagename parameter for a list of
   required images). If the SD image is available but not the PSF, a generic Gaussian PSF can be created with a tool from the
   sdintimaging task. This code creates a PSF for the M100 SD image and deconvolves it.

   .. code-block:: python

      from casatools import ctsys
      m100path = ctsys.resolve('M100_TP')

      # Use the SDINT_helper class to create the PSF.
      # The SDINT_helper utility class is in the "private" directory of the wrapped python sdintimaging 
      # task code. To access the sdint_helper file, we need to tell python EXACTLY where
      # sdint_helper.py is.
      sys.path.append(casatasks.__path__[0] + "/private/")
      from sdint_helper import *
      sdintlib = SDINT_helper()

      # get/rename the residual image
      os.system("cp -rp "+m100path+" M100_SD.residual")

      # get/rename, or create, the psf image
      # os.system("cp -rp psf_for_m100_tp M100_SD.psf")
      # Create a PSF cube with Gaussians derived from restoringbeam information in the residual image
      sdintlib.create_sd_psf("M100_SD.residual", "M100_SD.psf")

      # deconvolve input: .residual .psf
      # output: .image .mask .model .residual
      ret=deconvolve(imagename="M100_SD", deconvolver="multiscale", scales=[0,5,15], niter=100,
                     threshold='0.0mJ')

   .. TODO uncomment in CAS-13570 once test_multirun_mtmfs3x passes
   .. Note: the creation of PSFs this way only works for 2D/3D SD images/cubes. It does not work for Taylor-term images, such as
   .. those generated by tclean(deconvolver='mtmfs'). The conversion from cube to Taylor-term inputs for use with deconvolve will
   .. be demonstrated at a later time.

   .. _Updating_Deconvolve_Scripts:
   .. rubric:: Updating Deconvolve Scripts

   The parameters differ slightly from the old deconvolve task. If you are updating old scripts from before CASA 6.1.3 to use
   this new deconvolve task, the following steps should be followed:

      1. Add code that copies the images to be deconvolved to the “model” output image name before deconvolving.
      2. Some of the parameters need to be renamed, from “alg” and “prior” to “deconvolver” and “startmodel”.
      3. The “imagename” parameter now describes the prefix part of the image and PSF names, and any suffixes
         (such as “.image” or “.residual”) should be removed.
      4. The parameters “targetflux” and “sigma” for MEM cleaning, and using strings to describe the PSF are no longer
         supported. These parameters must be dropped. If no PSF is available to use, one can be created as described in the
         `Working with SD Images example <Working_with_SD_Images_>`_.

   For example, this:
   
   .. code-block:: python

      deconvolve(imagename='mydirtyimage.image', model='mycleanimage.image', psf='mydirtyimage.psf',
                 alg='multiscale', scales=[0,3,10], niter=10000, gain=0.1, threshold='10mJy')

   ..becomes this:

   .. code-block:: python
   
      import shutil
      shutil.copytree('mydirtyimage.image', 'mycleanimage.residual')
      shutil.copytree('mydirtyimage.psf', 'mycleanimage.psf')
      deconvolve(imagename='mycleanimage', deconvolver='multiscale', scales=[0,3,10], niter=10000, 
                 gain=0.1, threshold='10mJy')

   

.. _Development:

Development   
   The deconvolve python code was copied from and mirrors tclean's code, including a copy of `imager_base.py` as
   `imager_deconvolver.py` that has many of the parameters for tclean stripped out.

   .. note:: There is a bug with hogbom `multirun <Multiple_Runs_>`_ that causes it to evaluate for
             1 more iteration than requested. So to compare the multiple runs results to single run
             results for hogbom, evaluate deconvolve with 19 and 9x2 iterations, instead of 20 and
             10x2 iterations as in these examples
             (i.e. deconvolve(niter=19) = deconvolve(9)+deconvolve(9) to get 20 iterations in total).
